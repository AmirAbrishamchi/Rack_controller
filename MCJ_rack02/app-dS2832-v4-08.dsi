;
; dS2832 Application File
;
const		AppMajor	4					; version of this application
const		AppMinor	8
const		AppVersion	(AppMajor*256)+AppMinor

const       MinRelayPulse   19              ; 19 for 20mS minimum pulse width. 

;******************************************************************************************
;** Flash configuration variables.
;** These are kept together, and in the same order so they can be used across all modules
;** with the Save/Restore commands in the IDE.
;******************************************************************************************

flint32     unused        ; was initControl, now moved to eeprom. This remains as a place holder so that previously save configs still work.

flstring	System_HostName[21]
flstring	System_IP[16]
flstring	System_SubNet[16]
flstring	System_Gateway[16]
flstring	System_DNS1[16]
flstring	System_DNS2[16]
flint32		System_TcpPort
flint32		System_HttpPort
flint8		System_Cmd
flint8		System_EnablePW
flint8		System_EnableDHCP
flstring	System_Password[201]
flstring	System_AES_key[33]
flstring    System_PW[10]

const       NAMESIZE    21
const       BOOLSIZE    51

flstring    System_AD1Name[NAMESIZE]
flstring    System_AD2Name[NAMESIZE]
flstring    System_AD3Name[NAMESIZE]
flstring    System_AD4Name[NAMESIZE]

flint32		System_ModbusUID
flint8		System_ModbusBaud
flint8		System_ModbusParity

flstring	System_Rly1Name[NAMESIZE]
flstring	System_Rly1Bool[BOOLSIZE]
flstring	System_Rly1Set[BOOLSIZE]
flstring	System_Rly1Rst[BOOLSIZE]
flstring	System_Rly1Tog[BOOLSIZE]

flstring	System_Rly2Name[NAMESIZE]
flstring	System_Rly2Bool[BOOLSIZE]
flstring	System_Rly2Set[BOOLSIZE]
flstring	System_Rly2Rst[BOOLSIZE]
flstring	System_Rly2Tog[BOOLSIZE]

flstring	System_Rly3Name[NAMESIZE]
flstring	System_Rly3Bool[BOOLSIZE]
flstring	System_Rly3Set[BOOLSIZE]
flstring	System_Rly3Rst[BOOLSIZE]
flstring	System_Rly3Tog[BOOLSIZE]

flstring	System_Rly4Name[NAMESIZE]
flstring	System_Rly4Bool[BOOLSIZE]
flstring	System_Rly4Set[BOOLSIZE]
flstring	System_Rly4Rst[BOOLSIZE]
flstring	System_Rly4Tog[BOOLSIZE]

flstring	System_Rly5Name[NAMESIZE]
flstring	System_Rly5Bool[BOOLSIZE]
flstring	System_Rly5Set[BOOLSIZE]
flstring	System_Rly5Rst[BOOLSIZE]
flstring	System_Rly5Tog[BOOLSIZE]

flstring	System_Rly6Name[NAMESIZE]
flstring	System_Rly6Bool[BOOLSIZE]
flstring	System_Rly6Set[BOOLSIZE]
flstring	System_Rly6Rst[BOOLSIZE]
flstring	System_Rly6Tog[BOOLSIZE]

flstring	System_Rly7Name[NAMESIZE]
flstring	System_Rly7Bool[BOOLSIZE]
flstring	System_Rly7Set[BOOLSIZE]
flstring	System_Rly7Rst[BOOLSIZE]
flstring	System_Rly7Tog[BOOLSIZE]

flstring	System_Rly8Name[NAMESIZE]
flstring	System_Rly8Bool[BOOLSIZE]
flstring	System_Rly8Set[BOOLSIZE]
flstring	System_Rly8Rst[BOOLSIZE]
flstring	System_Rly8Tog[BOOLSIZE]

flstring	System_Rly9Name[NAMESIZE]
flstring	System_Rly9Bool[BOOLSIZE]
flstring	System_Rly9Set[BOOLSIZE]
flstring	System_Rly9Rst[BOOLSIZE]
flstring	System_Rly9Tog[BOOLSIZE]

flstring	System_Rly10Name[NAMESIZE]
flstring	System_Rly10Bool[BOOLSIZE]
flstring	System_Rly10Set[BOOLSIZE]
flstring	System_Rly10Rst[BOOLSIZE]
flstring	System_Rly10Tog[BOOLSIZE]

flstring	System_Rly11Name[NAMESIZE]
flstring	System_Rly11Bool[BOOLSIZE]
flstring	System_Rly11Set[BOOLSIZE]
flstring	System_Rly11Rst[BOOLSIZE]
flstring	System_Rly11Tog[BOOLSIZE]

flstring	System_Rly12Name[NAMESIZE]
flstring	System_Rly12Bool[BOOLSIZE]
flstring	System_Rly12Set[BOOLSIZE]
flstring	System_Rly12Rst[BOOLSIZE]
flstring	System_Rly12Tog[BOOLSIZE]

flstring	System_Rly13Name[NAMESIZE]
flstring	System_Rly13Bool[BOOLSIZE]
flstring	System_Rly13Set[BOOLSIZE]
flstring	System_Rly13Rst[BOOLSIZE]
flstring	System_Rly13Tog[BOOLSIZE]

flstring	System_Rly14Name[NAMESIZE]
flstring	System_Rly14Bool[BOOLSIZE]
flstring	System_Rly14Set[BOOLSIZE]
flstring	System_Rly14Rst[BOOLSIZE]
flstring	System_Rly14Tog[BOOLSIZE]

flstring	System_Rly15Name[NAMESIZE]
flstring	System_Rly15Bool[BOOLSIZE]
flstring	System_Rly15Set[BOOLSIZE]
flstring	System_Rly15Rst[BOOLSIZE]
flstring	System_Rly15Tog[BOOLSIZE]

flstring	System_Rly16Name[NAMESIZE]
flstring	System_Rly16Bool[BOOLSIZE]
flstring	System_Rly16Set[BOOLSIZE]
flstring	System_Rly16Rst[BOOLSIZE]
flstring	System_Rly16Tog[BOOLSIZE]

flstring	System_Rly17Name[NAMESIZE]
flstring	System_Rly17Bool[BOOLSIZE]
flstring	System_Rly17Set[BOOLSIZE]
flstring	System_Rly17Rst[BOOLSIZE]
flstring	System_Rly17Tog[BOOLSIZE]

flstring	System_Rly18Name[NAMESIZE]
flstring	System_Rly18Bool[BOOLSIZE]
flstring	System_Rly18Set[BOOLSIZE]
flstring	System_Rly18Rst[BOOLSIZE]
flstring	System_Rly18Tog[BOOLSIZE]

flstring	System_Rly19Name[NAMESIZE]
flstring	System_Rly19Bool[BOOLSIZE]
flstring	System_Rly19Set[BOOLSIZE]
flstring	System_Rly19Rst[BOOLSIZE]
flstring	System_Rly19Tog[BOOLSIZE]

flstring	System_Rly20Name[NAMESIZE]
flstring	System_Rly20Bool[BOOLSIZE]
flstring	System_Rly20Set[BOOLSIZE]
flstring	System_Rly20Rst[BOOLSIZE]
flstring	System_Rly20Tog[BOOLSIZE]

flstring	System_Rly21Name[NAMESIZE]
flstring	System_Rly21Bool[BOOLSIZE]
flstring	System_Rly21Set[BOOLSIZE]
flstring	System_Rly21Rst[BOOLSIZE]
flstring	System_Rly21Tog[BOOLSIZE]

flstring	System_Rly22Name[NAMESIZE]
flstring	System_Rly22Bool[BOOLSIZE]
flstring	System_Rly22Set[BOOLSIZE]
flstring	System_Rly22Rst[BOOLSIZE]
flstring	System_Rly22Tog[BOOLSIZE]

flstring	System_Rly23Name[NAMESIZE]
flstring	System_Rly23Bool[BOOLSIZE]
flstring	System_Rly23Set[BOOLSIZE]
flstring	System_Rly23Rst[BOOLSIZE]
flstring	System_Rly23Tog[BOOLSIZE]

flstring	System_Rly24Name[NAMESIZE]
flstring	System_Rly24Bool[BOOLSIZE]
flstring	System_Rly24Set[BOOLSIZE]
flstring	System_Rly24Rst[BOOLSIZE]
flstring	System_Rly24Tog[BOOLSIZE]

flstring	System_Rly25Name[NAMESIZE]
flstring	System_Rly25Bool[BOOLSIZE]
flstring	System_Rly25Set[BOOLSIZE]
flstring	System_Rly25Rst[BOOLSIZE]
flstring	System_Rly25Tog[BOOLSIZE]

flstring	System_Rly26Name[NAMESIZE]
flstring	System_Rly26Bool[BOOLSIZE]
flstring	System_Rly26Set[BOOLSIZE]
flstring	System_Rly26Rst[BOOLSIZE]
flstring	System_Rly26Tog[BOOLSIZE]

flstring	System_Rly27Name[NAMESIZE]
flstring	System_Rly27Bool[BOOLSIZE]
flstring	System_Rly27Set[BOOLSIZE]
flstring	System_Rly27Rst[BOOLSIZE]
flstring	System_Rly27Tog[BOOLSIZE]

flstring	System_Rly28Name[NAMESIZE]
flstring	System_Rly28Bool[BOOLSIZE]
flstring	System_Rly28Set[BOOLSIZE]
flstring	System_Rly28Rst[BOOLSIZE]
flstring	System_Rly28Tog[BOOLSIZE]

flstring	System_Rly29Name[NAMESIZE]
flstring	System_Rly29Bool[BOOLSIZE]
flstring	System_Rly29Set[BOOLSIZE]
flstring	System_Rly29Rst[BOOLSIZE]
flstring	System_Rly29Tog[BOOLSIZE]

flstring	System_Rly30Name[NAMESIZE]
flstring	System_Rly30Bool[BOOLSIZE]
flstring	System_Rly30Set[BOOLSIZE]
flstring	System_Rly30Rst[BOOLSIZE]
flstring	System_Rly30Tog[BOOLSIZE]

flstring	System_Rly31Name[NAMESIZE]
flstring	System_Rly31Bool[BOOLSIZE]
flstring	System_Rly31Set[BOOLSIZE]
flstring	System_Rly31Rst[BOOLSIZE]
flstring	System_Rly31Tog[BOOLSIZE]

flstring	System_Rly32Name[NAMESIZE]
flstring	System_Rly32Bool[BOOLSIZE]
flstring	System_Rly32Set[BOOLSIZE]
flstring	System_Rly32Rst[BOOLSIZE]
flstring	System_Rly32Tog[BOOLSIZE]

flstring	System_IO1Name[NAMESIZE]
flstring	System_IO2Name[NAMESIZE]
flstring	System_IO3Name[NAMESIZE]
flstring	System_IO4Name[NAMESIZE]
flstring	System_IO5Name[NAMESIZE]
flstring	System_IO6Name[NAMESIZE]
flstring	System_IO7Name[NAMESIZE]
flstring	System_IO8Name[NAMESIZE]

flint8		System_IO1Type
flint8		System_IO2Type
flint8		System_IO3Type
flint8		System_IO4Type
flint8		System_IO5Type
flint8		System_IO6Type
flint8		System_IO7Type
flint8		System_IO8Type

flint8		System_IO1AttachedRly
flint8		System_IO2AttachedRly
flint8		System_IO3AttachedRly
flint8		System_IO4AttachedRly
flint8		System_IO5AttachedRly
flint8		System_IO6AttachedRly
flint8		System_IO7AttachedRly
flint8		System_IO8AttachedRly

flint32     System_RLY_PUR

const		EMAILSIZE1	101
const		EMAILSIZE2	151
flstring	System_EmailFromAddr[EMAILSIZE1]
flstring	System_EmailAddr1[EMAILSIZE1]
flstring	System_EmailAddr2[EMAILSIZE1]
flstring	System_EmailAddr3[EMAILSIZE1]
flstring	System_EmailAddr4[EMAILSIZE1]
flstring	System_EmailAddr5[EMAILSIZE1]
flstring	System_EmailAddr6[EMAILSIZE1]
flstring	System_EmailAddr7[EMAILSIZE1]
flstring	System_EmailAddr8[EMAILSIZE1]
flstring	System_EmailSubject1[EMAILSIZE2]
flstring	System_EmailSubject2[EMAILSIZE2]
flstring	System_EmailSubject3[EMAILSIZE2]
flstring	System_EmailSubject4[EMAILSIZE2]
flstring	System_EmailSubject5[EMAILSIZE2]
flstring	System_EmailSubject6[EMAILSIZE2]
flstring	System_EmailSubject7[EMAILSIZE2]
flstring	System_EmailSubject8[EMAILSIZE2]
flstring	System_EmailTrigger1[BOOLSIZE]
flstring	System_EmailTrigger2[BOOLSIZE]
flstring	System_EmailTrigger3[BOOLSIZE]
flstring	System_EmailTrigger4[BOOLSIZE]
flstring	System_EmailTrigger5[BOOLSIZE]
flstring	System_EmailTrigger6[BOOLSIZE]
flstring	System_EmailTrigger7[BOOLSIZE]
flstring	System_EmailTrigger8[BOOLSIZE]

const		P2PSIZE1	51
flstring	System_P2P_Input1[BOOLSIZE]
flstring	System_P2P_Input2[BOOLSIZE]
flstring	System_P2P_Input3[BOOLSIZE]
flstring	System_P2P_Input4[BOOLSIZE]
flstring	System_P2P_Input5[BOOLSIZE]
flstring	System_P2P_Input6[BOOLSIZE]
flstring	System_P2P_Input7[BOOLSIZE]
flstring	System_P2P_Input8[BOOLSIZE]
flstring	System_P2P_IP1[P2PSIZE1]
flstring	System_P2P_IP2[P2PSIZE1]
flstring	System_P2P_IP3[P2PSIZE1]
flstring	System_P2P_IP4[P2PSIZE1]
flstring	System_P2P_IP5[P2PSIZE1]
flstring	System_P2P_IP6[P2PSIZE1]
flstring	System_P2P_IP7[P2PSIZE1]
flstring	System_P2P_IP8[P2PSIZE1]
flint32		System_P2P_Port1
flint32		System_P2P_Port2
flint32		System_P2P_Port3
flint32		System_P2P_Port4
flint32		System_P2P_Port5
flint32		System_P2P_Port6
flint32		System_P2P_Port7
flint32		System_P2P_Port8
flint32		System_P2P_Relay1
flint32		System_P2P_Relay2
flint32		System_P2P_Relay3
flint32		System_P2P_Relay4
flint32		System_P2P_Relay5
flint32		System_P2P_Relay6
flint32		System_P2P_Relay7
flint32		System_P2P_Relay8
flint32		System_P2P_Action1
flint32		System_P2P_Action2
flint32		System_P2P_Action3
flint32		System_P2P_Action4
flint32		System_P2P_Action5
flint32		System_P2P_Action6
flint32		System_P2P_Action7
flint32		System_P2P_Action8
flint32		System_P2P_Timeout1
flint32		System_P2P_Timeout2
flint32		System_P2P_Timeout3
flint32		System_P2P_Timeout4
flint32		System_P2P_Timeout5
flint32		System_P2P_Timeout6
flint32		System_P2P_Timeout7
flint32		System_P2P_Timeout8
flint32		System_P2P_AES

flint8      System_Sch_R1
flint8      System_Sch_STH1a    ; Start 1
flint8      System_Sch_STM1a
flint8      System_Sch_STS1a
flint8      System_Sch_SPH1a    ; Stop 1
flint8      System_Sch_SPM1a
flint8      System_Sch_SPS1a
flint8      System_Sch_STH1b    ; Start 2
flint8      System_Sch_STM1b
flint8      System_Sch_STS1b
flint8      System_Sch_SPH1b    ; Stop 2
flint8      System_Sch_SPM1b
flint8      System_Sch_SPS1b
flint8      System_Sch_WD1      ; W/Days

flint8      System_Sch_R2
flint8      System_Sch_STH2a    ; Start 1
flint8      System_Sch_STM2a
flint8      System_Sch_STS2a
flint8      System_Sch_SPH2a    ; Stop 1
flint8      System_Sch_SPM2a
flint8      System_Sch_SPS2a
flint8      System_Sch_STH2b    ; Start 2
flint8      System_Sch_STM2b
flint8      System_Sch_STS2b
flint8      System_Sch_SPH2b    ; Stop 2
flint8      System_Sch_SPM2b
flint8      System_Sch_SPS2b
flint8      System_Sch_WD2      ; W/Days

flint8      System_Sch_R3
flint8      System_Sch_STH3a    ; Start 1
flint8      System_Sch_STM3a
flint8      System_Sch_STS3a
flint8      System_Sch_SPH3a    ; Stop 1
flint8      System_Sch_SPM3a
flint8      System_Sch_SPS3a
flint8      System_Sch_STH3b    ; Start 2
flint8      System_Sch_STM3b
flint8      System_Sch_STS3b
flint8      System_Sch_SPH3b    ; Stop 2
flint8      System_Sch_SPM3b
flint8      System_Sch_SPS3b
flint8      System_Sch_WD3      ; W/Days

flint8      System_Sch_R4
flint8      System_Sch_STH4a    ; Start 1
flint8      System_Sch_STM4a
flint8      System_Sch_STS4a
flint8      System_Sch_SPH4a    ; Stop 1
flint8      System_Sch_SPM4a
flint8      System_Sch_SPS4a
flint8      System_Sch_STH4b    ; Start 2
flint8      System_Sch_STM4b
flint8      System_Sch_STS4b
flint8      System_Sch_SPH4b    ; Stop 2
flint8      System_Sch_SPM4b
flint8      System_Sch_SPS4b
flint8      System_Sch_WD4      ; W/Days

flint8      System_Sch_R5
flint8      System_Sch_STH5a    ; Start 1
flint8      System_Sch_STM5a
flint8      System_Sch_STS5a
flint8      System_Sch_SPH5a    ; Stop 1
flint8      System_Sch_SPM5a
flint8      System_Sch_SPS5a
flint8      System_Sch_STH5b    ; Start 2
flint8      System_Sch_STM5b
flint8      System_Sch_STS5b
flint8      System_Sch_SPH5b    ; Stop 2
flint8      System_Sch_SPM5b
flint8      System_Sch_SPS5b
flint8      System_Sch_WD5      ; W/Days

flint8      System_Sch_R6
flint8      System_Sch_STH6a    ; Start 1
flint8      System_Sch_STM6a
flint8      System_Sch_STS6a
flint8      System_Sch_SPH6a    ; Stop 1
flint8      System_Sch_SPM6a
flint8      System_Sch_SPS6a
flint8      System_Sch_STH6b    ; Start 2
flint8      System_Sch_STM6b
flint8      System_Sch_STS6b
flint8      System_Sch_SPH6b    ; Stop 2
flint8      System_Sch_SPM6b
flint8      System_Sch_SPS6b
flint8      System_Sch_WD6      ; W/Days

flint8      System_Sch_R7
flint8      System_Sch_STH7a    ; Start 1
flint8      System_Sch_STM7a
flint8      System_Sch_STS7a
flint8      System_Sch_SPH7a    ; Stop 1
flint8      System_Sch_SPM7a
flint8      System_Sch_SPS7a
flint8      System_Sch_STH7b    ; Start 2
flint8      System_Sch_STM7b
flint8      System_Sch_STS7b
flint8      System_Sch_SPH7b    ; Stop 2
flint8      System_Sch_SPM7b
flint8      System_Sch_SPS7b
flint8      System_Sch_WD7      ; W/Days

flint8      System_Sch_R8
flint8      System_Sch_STH8a    ; Start 1
flint8      System_Sch_STM8a
flint8      System_Sch_STS8a
flint8      System_Sch_SPH8a    ; Stop 1
flint8      System_Sch_SPM8a
flint8      System_Sch_SPS8a
flint8      System_Sch_STH8b    ; Start 2
flint8      System_Sch_STM8b
flint8      System_Sch_STS8b
flint8      System_Sch_SPH8b    ; Stop 2
flint8      System_Sch_SPM8b
flint8      System_Sch_SPS8b
flint8      System_Sch_WD8      ; W/Days

flstring    System_CtrName1[NAMESIZE]
flstring    System_CtrName2[NAMESIZE]
flstring    System_CtrName3[NAMESIZE]
flstring    System_CtrName4[NAMESIZE]
flstring    System_CtrName5[NAMESIZE]
flstring    System_CtrName6[NAMESIZE]
flstring    System_CtrName7[NAMESIZE]
flstring    System_CtrName8[NAMESIZE]
flstring    System_CtrReset1[BOOLSIZE]
flstring    System_CtrReset2[BOOLSIZE]
flstring    System_CtrReset3[BOOLSIZE]
flstring    System_CtrReset4[BOOLSIZE]
flstring    System_CtrReset5[BOOLSIZE]
flstring    System_CtrReset6[BOOLSIZE]
flstring    System_CtrReset7[BOOLSIZE]
flstring    System_CtrReset8[BOOLSIZE]
flstring    System_CtrCount1[BOOLSIZE]
flstring    System_CtrCount2[BOOLSIZE]
flstring    System_CtrCount3[BOOLSIZE]
flstring    System_CtrCount4[BOOLSIZE]
flstring    System_CtrCount5[BOOLSIZE]
flstring    System_CtrCount6[BOOLSIZE]
flstring    System_CtrCount7[BOOLSIZE]
flstring    System_CtrCount8[BOOLSIZE]
flstring    System_CtrCap1[BOOLSIZE]
flstring    System_CtrCap2[BOOLSIZE]
flstring    System_CtrCap3[BOOLSIZE]
flstring    System_CtrCap4[BOOLSIZE]
flstring    System_CtrCap5[BOOLSIZE]
flstring    System_CtrCap6[BOOLSIZE]
flstring    System_CtrCap7[BOOLSIZE]
flstring    System_CtrCap8[BOOLSIZE]

flstring    TimeZone[10]
flint32     DaylightSaving

const       HOSTSIZE 51
flstring    System_PingHost1[HOSTSIZE]                          ; Ping control variable
flstring    System_PingHost2[HOSTSIZE]
flstring    System_PingHost3[HOSTSIZE]
flstring    System_PingHost4[HOSTSIZE]
flint32     System_PingRepeat1
flint32     System_PingRepeat2
flint32     System_PingRepeat3
flint32     System_PingRepeat4
flint32     System_PingAttempts1
flint32     System_PingAttempts2
flint32     System_PingAttempts3
flint32     System_PingAttempts4
flint32     System_PingDelay1
flint32     System_PingDelay2
flint32     System_PingDelay3
flint32     System_PingDelay4

flint32     sequencer[128]

;******************* End of Flash configuration Variables *********************************


int32		P2Pbool1
int32		P2Pbool2
int32		P2Pbool3
int32		P2Pbool4
int32		P2Pbool5
int32		P2Pbool6
int32		P2Pbool7
int32		P2Pbool8
int32		P2Pbool
int32		P2Plength
int32		P2P_AES

string		P2Pcmd[50]
string		nonce[50]

clientport	p2p1 System_P2P_IP1 System_P2P_Port1 System_P2P_Timeout1
clientport	p2p2 System_P2P_IP2 System_P2P_Port2 System_P2P_Timeout2
clientport	p2p3 System_P2P_IP3 System_P2P_Port3 System_P2P_Timeout3
clientport	p2p4 System_P2P_IP4 System_P2P_Port4 System_P2P_Timeout4
clientport	p2p5 System_P2P_IP5 System_P2P_Port5 System_P2P_Timeout5
clientport	p2p6 System_P2P_IP6 System_P2P_Port6 System_P2P_Timeout6
clientport	p2p7 System_P2P_IP7 System_P2P_Port7 System_P2P_Timeout7
clientport	p2p8 System_P2P_IP8 System_P2P_Port8 System_P2P_Timeout8

int32        aX
int32       RLY_PUR
int8        RlySetTrn[33]
int8        RlyRstTrn[33]
int8        RlyTogTrn[33]

int32		System_CtrVal1
int32		System_CtrVal2
int32		System_CtrVal3
int32		System_CtrVal4
int32		System_CtrVal5
int32		System_CtrVal6
int32		System_CtrVal7
int32		System_CtrVal8
int32		System_CtrCapt1
int32		System_CtrCapt2
int32		System_CtrCapt3
int32		System_CtrCapt4
int32		System_CtrCapt5
int32		System_CtrCapt6
int32		System_CtrCapt7
int32		System_CtrCapt8
setcounters	System_CtrVal1 System_CtrVal2 System_CtrVal3 System_CtrVal4 System_CtrVal5 System_CtrVal6 System_CtrVal7 System_CtrVal8

int8		CTreset[9]
int8		CTcount[9]
int8		CTcapt[9]

int32		SchT
int32		SystemWDayUpdated

int32		SchStartA[9]
int32		SchStopA[9]
int32		SchStartB[9]
int32		SchStopB[9]
int8		SchWDay[9]
int8		SchRelays[9]
int8		SchStatus[9]
int32		SchX
int32		schState

UTCport		UTC TimeZone DaylightSaving
;UTCport		UTC 0 1
int8		Hours
int8		Minutes
int8		Seconds
int32		UseDST

int32       PingIP1
int32       PingIP2
int32       PingIP3
int32       PingIP4
int32       PingTimer1                                          ; PingTimer and PingTime are to double buffer the result
int32       PingTimer2
int32       PingTimer3
int32       PingTimer4
int32       PingTime1
int32       PingTime2
int32       PingTime3
int32       PingTime4
setpingtimers  PingTime1 PingTime2 PingTime3 PingTime4

int32       seqUpdateOutput
int32       seqUpdateCmd
int32       seqrow
int32       seq1Handle
int32       seq1Timer
int32       Koutputs
setkoutputs Koutputs

easymail	em1	System_EmailAddr1, System_EmailFromAddr			; To Address, From Address
easymail	em2	System_EmailAddr2, System_EmailFromAddr
easymail	em3	System_EmailAddr3, System_EmailFromAddr
easymail	em4	System_EmailAddr4, System_EmailFromAddr
easymail	em5	System_EmailAddr5, System_EmailFromAddr
easymail	em6	System_EmailAddr6, System_EmailFromAddr
easymail	em7	System_EmailAddr7, System_EmailFromAddr
easymail	em8	System_EmailAddr8, System_EmailFromAddr

int32	eIdx						; index and
int8	armed[8]					; emails armed array.
int32	eResponse					; returned from sending the email
int32	eX
string	msg[1000]					; for automated response

tcpip.ip		System_IP
tcpip.mask		System_SubNet
tcpip.hostname	System_HostName
tcpip.port		System_TcpPort
tcpip.dns1		System_DNS1
tcpip.dns2		System_DNS2
tcpip.gateway	System_Gateway
tcpip.dhcp		System_EnableDHCP

html.password	System_Password
html.port 		System_HttpPort
html.setup 		System_EnablePW

aes.key			System_AES_key 
int32			Nonce
int32			NonceIn

digitalport		Rly1	1
digitalport		Rly2	2
digitalport		Rly3	3
digitalport		Rly4	4
digitalport		Rly5	5
digitalport		Rly6	6
digitalport		Rly7	7
digitalport		Rly8	8
digitalport		Rly9	9
digitalport		Rly10	10
digitalport		Rly11	11
digitalport		Rly12	12
digitalport		Rly13	13
digitalport		Rly14	14
digitalport		Rly15	15
digitalport		Rly16	16
digitalport		Rly17	17
digitalport		Rly18	18
digitalport		Rly19	19
digitalport		Rly20	20
digitalport		Rly21	21
digitalport		Rly22	22
digitalport		Rly23	23
digitalport		Rly24	24
digitalport		Rly25	25
digitalport		Rly26	26
digitalport		Rly27	27
digitalport		Rly28	28
digitalport		Rly29	29
digitalport		Rly30	30
digitalport		Rly31	31
digitalport		Rly32	32

digitalport	LedBlue		33
digitalport	LedGreen	34
digitalport	LedRed		35

flexport	IO1		1	System_IO1Type
flexport	IO2		2	System_IO2Type
flexport	IO3		3	System_IO3Type
flexport	IO4		4	System_IO4Type
flexport	IO5		5	System_IO5Type
flexport	IO6		6	System_IO6Type
flexport	IO7		7	System_IO7Type
flexport	IO8		8	System_IO8Type

flexport	IO1_s	9	 	; These are read-only status bits.
flexport	IO2_s	10  	;   7   6    5     4    3   2 1 0
flexport	IO3_s	11		; | x | x | Out | Inp | x | Mode |
flexport	IO4_s	12 		;
flexport	IO5_s	13 		; x     unused
flexport	IO6_s	14 		; Out	Ouput, 0=inactive, 1=active
flexport	IO7_s	15 		; Inp	Input, could be from actual input or result of driving the output active.
flexport	IO8_s	16 		; mode	0=digital no pullup, 1=digital with pullup, 4=analog 4.096v ref, 5=analog 5v ref.


analogport	TS1		100	; on-board temp sensor
analogport	PSU		101	; DC power voltage

int32 BrdTemp
int32 Volts

string AsciiChecked[8]
string ModBusChecked[8]
string BinaryChecked[8]
string AESChecked[8]
string PWChecked[8]
string DHCPChecked[8]
string PhoneChecked[8]

string Module[30]
int32 VerMajor
int32 VerMinor
int32 AppVerMajor
int32 AppVerMinor

int32	RlyState
int32	Rly1tmr
int32	Rly2tmr
int32	Rly3tmr
int32	Rly4tmr
int32	PulseTime

int32 	cmdIdx
int32	cmdIO
int32	cmdPulseTime
string	cmdAction[20]
string	cmdPassWord[20]
string	cmdStr[20]

int32	tcpLength
string	tcpInBuf[1024]
string	tcpOutBuf[300]
string	rtu[300]
int32	crc

string	CLS[4]						; Loaded with LCD05 clear screen commands
string	CR[3]						; Loaded with Carriage Return 0x0d, 0x0a (or 13, 10 if you prefer)

int32	mbTI						; ModBus variables, Transaction Identifier
int32	mbPI						; Protocol Indentifier
int32	mbLen						; Length
int32	mbUI						; Unit Identifier
int32	mbFC						; Function Code
int32	mbSA						; Start Address
int32	mbNP						; Number of Points
int32 	mbX							; General Purpose

int32	SystemCmdUpdated			; used to tell when webpage updates "System_Cmd"
int32	SystemRlysUpdated			; updated from webpage to toggle/pulse relays - contains relay number
int32	FlashWritePending			; indicate to config pages that a flash write is pending

int32	RBP							; used by boolean eval
int32	x
int32	Zero

eeint32 initControl
eeint8	RelayStore[32]				; to restore relays after power outage

int8	AttachedRly
int8	AttachedRlyState
int32   SystemReset                 ; set by webpage to request a reboot

string  System_MAC[20]              ; holds this modules formatted MAC address
string	s1[100]
serialport LCD05 1 10 90
serialport ModbusRTU 3 300 300

thread DST(UseDST)
	if DaylightSaving==1 then DaylightSaving=0 else DaylightSaving=1 endif
	UseDST = 0;
endthread
	
thread P2PAES(P2P_AES)
	select P2P_AES
		case 1 System_P2P_AES ^= 0x01
		case 2 System_P2P_AES ^= 0x02
		case 3 System_P2P_AES ^= 0x04
		case 4 System_P2P_AES ^= 0x08
		case 5 System_P2P_AES ^= 0x10
		case 6 System_P2P_AES ^= 0x20
		case 7 System_P2P_AES ^= 0x40
		case 8 System_P2P_AES ^= 0x80			
	endselect
	P2P_AES = 0
endthread


thread Reboot(SystemReset)      ; thread is triggered when webpage sets "SystemReset" to non-zero.
    x = system.Restart          ; no further processing after this  (CPU is reset)
endthread

thread RLYPUR(RLY_PUR)
	select RLY_PUR
		case 1 System_RLY_PUR ^= 0x01
		case 2 System_RLY_PUR ^= 0x02
		case 3 System_RLY_PUR ^= 0x04
		case 4 System_RLY_PUR ^= 0x08
		case 5 System_RLY_PUR ^= 0x10
		case 6 System_RLY_PUR ^= 0x20
		case 7 System_RLY_PUR ^= 0x40
		case 8 System_RLY_PUR ^= 0x80			
		case 9 System_RLY_PUR ^= 0x0100
		case 10 System_RLY_PUR ^= 0x0200
		case 11 System_RLY_PUR ^= 0x0400
		case 12 System_RLY_PUR ^= 0x0800
		case 13 System_RLY_PUR ^= 0x1000
		case 14 System_RLY_PUR ^= 0x2000
		case 15 System_RLY_PUR ^= 0x4000
		case 16 System_RLY_PUR ^= 0x8000			
		case 17 System_RLY_PUR ^= 0x010000
		case 18 System_RLY_PUR ^= 0x020000
		case 19 System_RLY_PUR ^= 0x040000
		case 20 System_RLY_PUR ^= 0x080000
		case 21 System_RLY_PUR ^= 0x100000
		case 22 System_RLY_PUR ^= 0x200000
		case 23 System_RLY_PUR ^= 0x400000
		case 24 System_RLY_PUR ^= 0x800000			
		case 25 System_RLY_PUR ^= 0x01000000
		case 26 System_RLY_PUR ^= 0x02000000
		case 27 System_RLY_PUR ^= 0x04000000
		case 28 System_RLY_PUR ^= 0x08000000
		case 29 System_RLY_PUR ^= 0x10000000
		case 30 System_RLY_PUR ^= 0x20000000
		case 31 System_RLY_PUR ^= 0x40000000
		case 32 System_RLY_PUR ^= 0x80000000
	endselect
	RLY_PUR = 0
endthread

thread WDayUpdate(SystemWDayUpdated)
	select SystemWDayUpdated
		case 1 System_Sch_WD1 ^= 0x40
		case 2 System_Sch_WD1 ^= 0x20
		case 3 System_Sch_WD1 ^= 0x10
		case 4 System_Sch_WD1 ^= 0x08
		case 5 System_Sch_WD1 ^= 0x04
		case 6 System_Sch_WD1 ^= 0x02
		case 7 System_Sch_WD1 ^= 0x01
		case 8 System_Sch_WD2 ^= 0x40
		case 9 System_Sch_WD2 ^= 0x20
		case 10 System_Sch_WD2 ^= 0x10
		case 11 System_Sch_WD2 ^= 0x08
		case 12 System_Sch_WD2 ^= 0x04
		case 13 System_Sch_WD2 ^= 0x02
		case 14 System_Sch_WD2 ^= 0x01
		case 15 System_Sch_WD3 ^= 0x40
		case 16 System_Sch_WD3 ^= 0x20
		case 17 System_Sch_WD3 ^= 0x10
		case 18 System_Sch_WD3 ^= 0x08
		case 19 System_Sch_WD3 ^= 0x04
		case 20 System_Sch_WD3 ^= 0x02
		case 21 System_Sch_WD3 ^= 0x01
		case 22 System_Sch_WD4 ^= 0x40
		case 23 System_Sch_WD4 ^= 0x20
		case 24 System_Sch_WD4 ^= 0x10
		case 25 System_Sch_WD4 ^= 0x08
		case 26 System_Sch_WD4 ^= 0x04
		case 27 System_Sch_WD4 ^= 0x02
		case 28 System_Sch_WD4 ^= 0x01
		case 29 System_Sch_WD5 ^= 0x40
		case 30 System_Sch_WD5 ^= 0x20
		case 31 System_Sch_WD5 ^= 0x10
		case 32 System_Sch_WD5 ^= 0x08
		case 33 System_Sch_WD5 ^= 0x04
		case 34 System_Sch_WD5 ^= 0x02
		case 35 System_Sch_WD5 ^= 0x01
		case 36 System_Sch_WD6 ^= 0x40
		case 37 System_Sch_WD6 ^= 0x20
		case 38 System_Sch_WD6 ^= 0x10
		case 39 System_Sch_WD6 ^= 0x08
		case 40 System_Sch_WD6 ^= 0x04
		case 41 System_Sch_WD6 ^= 0x02
		case 42 System_Sch_WD6 ^= 0x01
		case 43 System_Sch_WD7 ^= 0x40
		case 44 System_Sch_WD7 ^= 0x20
		case 45 System_Sch_WD7 ^= 0x10
		case 46 System_Sch_WD7 ^= 0x08
		case 47 System_Sch_WD7 ^= 0x04
		case 48 System_Sch_WD7 ^= 0x02
		case 49 System_Sch_WD7 ^= 0x01
		case 50 System_Sch_WD8 ^= 0x40
		case 51 System_Sch_WD8 ^= 0x20
		case 52 System_Sch_WD8 ^= 0x10
		case 53 System_Sch_WD8 ^= 0x08
		case 54 System_Sch_WD8 ^= 0x04
		case 55 System_Sch_WD8 ^= 0x02
		case 56 System_Sch_WD8 ^= 0x01
	endselect
	SystemWDayUpdated = 0
endthread
		
thread Rly1Thread(const)			; These relay threads pulse the relay on for the pulsetime.
	Rly1 = on 				
	threadsleep PulseTime
	Rly1 = off
   
endthread
	
thread Rly2Thread(const)
	Rly2 = on 
	threadsleep PulseTime
	Rly2 = off
    
endthread
	
thread Rly3Thread(const)
	Rly3 = on 
	threadsleep PulseTime
	Rly3 = off
    
endthread
	
thread Rly4Thread(const)
	Rly4 = on 
	threadsleep PulseTime
	Rly4 = off
    
endthread
	
thread Rly5Thread(const)
	Rly5 = on 
	threadsleep PulseTime
	Rly5 = off
endthread
	
thread Rly6Thread(const)
	Rly6 = on 
	threadsleep PulseTime
	Rly6 = off
endthread
	
thread Rly7Thread(const)
	Rly7 = on 
	threadsleep PulseTime
	Rly7 = off
endthread
	
thread Rly8Thread(const)
	Rly8 = on 
	threadsleep PulseTime
	Rly8 = off
endthread
	
thread Rly9Thread(const)
	Rly9 = on 
	threadsleep PulseTime
	Rly9 = off
endthread
	
thread Rly10Thread(const)
	Rly10 = on 
	threadsleep PulseTime
	Rly10 = off
endthread
	
thread Rly11Thread(const)
	Rly11 = on 
	threadsleep PulseTime
	Rly11 = off
endthread
	
thread Rly12Thread(const)
	Rly12 = on 
	threadsleep PulseTime
	Rly12 = off
endthread
	
thread Rly13Thread(const)
	Rly13 = on 
	threadsleep PulseTime
	Rly13 = off
endthread
	
thread Rly14Thread(const)
	Rly14 = on 
	threadsleep PulseTime
	Rly14 = off
endthread
	
thread Rly15Thread(const)
	Rly15 = on 
	threadsleep PulseTime
	Rly15 = off
endthread
	
thread Rly16Thread(const)
	Rly16 = on 
	threadsleep PulseTime
	Rly16 = off
endthread
	
thread Rly17Thread(const)
	Rly17 = on 
	threadsleep PulseTime
	Rly17 = off
endthread
	
thread Rly18Thread(const)
	Rly18 = on 
	threadsleep PulseTime
	Rly18 = off
endthread
	
thread Rly19Thread(const)
	Rly19 = on 
	threadsleep PulseTime
	Rly19 = off
endthread
	
thread Rly20Thread(const)
	Rly20 = on 
	threadsleep PulseTime
	Rly20 = off
endthread
	
thread Rly21Thread(const)
	Rly21 = on 
	threadsleep PulseTime
	Rly21 = off
endthread
	
thread Rly22Thread(const)
	Rly22 = on 
	threadsleep PulseTime
	Rly22 = off
endthread
	
thread Rly23Thread(const)
	Rly23 = on 
	threadsleep PulseTime
	Rly23 = off
endthread
	
thread Rly24Thread(const)
	Rly24 = on 
	threadsleep PulseTime
	Rly24 = off
endthread
	
thread Rly25Thread(const)
	Rly25 = on 
	threadsleep PulseTime
	Rly25 = off
endthread
	
thread Rly26Thread(const)
	Rly26 = on 
	threadsleep PulseTime
	Rly26 = off
endthread
	
thread Rly27Thread(const)
	Rly27 = on 
	threadsleep PulseTime
	Rly27 = off
endthread
	
thread Rly28Thread(const)
	Rly28 = on 
	threadsleep PulseTime
	Rly28 = off
endthread
	
thread Rly29Thread(const)
	Rly29 = on 
	threadsleep PulseTime
	Rly29 = off
endthread
	
thread Rly30Thread(const)
	Rly30 = on 
	threadsleep PulseTime
	Rly30 = off
endthread
	
thread Rly31Thread(const)
	Rly31 = on 
	threadsleep PulseTime
	Rly31 = off
endthread
	
thread Rly32Thread(const)
	Rly32 = on 
	threadsleep PulseTime
	Rly32 = off
endthread


;  sequencer[row] format is:
;  A. 31:29 unused, 28:24 cmd, 23:19 Object num, 18:12 target row, 11:0 K outputs
;  B. 31:29 unused, 28:24 cmd, 23:12 Delay time, 11:0 K outputs
;
;  called when k1-k12 output status change on Sequence config screen
;  Bits 31:10 unused, 9:5 row, 4:1 col, 0 new checked state
thread SequencerUpdateOutputs(seqUpdateOutput)
int32 row
int32 col
int32 k
    row = (seqUpdateOutput/32)-1
    col = (seqUpdateOutput/2)&0x0f
    k = seqUpdateOutput&1
    select(col)
        case 1   if(k) then sequencer[row] |= 0x001 else sequencer[row] &= 0xfffffffe endif
        case 2   if(k) then sequencer[row] |= 0x002 else sequencer[row] &= 0xfffffffd endif
        case 3   if(k) then sequencer[row] |= 0x004 else sequencer[row] &= 0xfffffffb endif
        case 4   if(k) then sequencer[row] |= 0x008 else sequencer[row] &= 0xfffffff7 endif
        case 5   if(k) then sequencer[row] |= 0x010 else sequencer[row] &= 0xffffffef endif
        case 6   if(k) then sequencer[row] |= 0x020 else sequencer[row] &= 0xffffffdf endif
        case 7   if(k) then sequencer[row] |= 0x040 else sequencer[row] &= 0xffffffbf endif
        case 8   if(k) then sequencer[row] |= 0x080 else sequencer[row] &= 0xffffff7f endif
        case 9   if(k) then sequencer[row] |= 0x100 else sequencer[row] &= 0xfffffeff endif
        case 10  if(k) then sequencer[row] |= 0x200 else sequencer[row] &= 0xfffffdff endif
        case 11  if(k) then sequencer[row] |= 0x400 else sequencer[row] &= 0xfffffbff endif
        case 12  if(k) then sequencer[row] |= 0x800 else sequencer[row] &= 0xfffff7ff endif
    endselect

    seqUpdateOutput = 0;
    threadsuspend
endthread


;  sequencer[row] format is:
;  A. 31:29 unused, 28:24 cmd, 23:19 Object num, 18:12 target row, 11:0 K outputs
;  B. 31:29 unused, 28:24 cmd, 23:12 Delay time, 11:0 K outputs
;
;  called when control changes on Sequence config screen
;  Bits 31:24 unused, 23:19 cmd, 18:14 Rly num, 13:7 line (or 18:7 delay time), 6:0 row
thread SequencerUpdateCmds(seqUpdateCmd)
int32 row
int32 cmd
int32 dly
int16 v1
int16 v2

    cmd = seqUpdateCmd >> 19
    row = seqUpdateCmd & 0x7f
    dly = (seqUpdateCmd >> 7) & 0x0fff     
    v1 = (seqUpdateCmd >> 14) & 0x1f
    v2 = (seqUpdateCmd >> 7) & 0x7f

    sequencer[row] &= 0xfff         ; remove any previous command, leave K outputs
    sequencer[row] |= (cmd << 24)   ; merge the command
    select(cmd) 
        case 1 to 8                 ; secs, mS, M, H, J, C, U, X
            sequencer[row] |= (dly << 12)
        case 9 to 13                ; T, R, D, S, K
            sequencer[row] |= (v1 << 19)
            sequencer[row] |= (v2 << 12)
    endselect
    
    seqUpdateCmd = 0;
    threadsuspend
endthread


;  sequencer[row] format is:
;  A. 31:29 unused, 28:24 cmd, 23:19 Object num, 18:12 target row, 11:0 K outputs
;  B. 31:29 unused, 28:24 cmd, 23:12 Delay time, 11:0 K outputs
thread RunSequencer(const)
int32 cmd
int32 v1
int32 v2
int32 dly
int32 sp
int32 stack[4]
int16 k

    seqrow = 0
    sp = 0
    seq1Handle = system.ThreadHandle    
    do 
        do while (sequencer[0]&0x1ffff000)==0               ; sleep while first row has no command
            threadsleep 1000                                ; allows editing sequence without it running
            seqrow = 0
        loop 

        cmd = sequencer[seqrow]>>24
        v1 = (sequencer[seqrow]>>19)&0x1f
        v2 = (sequencer[seqrow]>>12)&0x7f
        dly = (sequencer[seqrow]>>12)&0x0fff
        select cmd
            case 1  Koutputs = sequencer[seqrow]&0xfff
                    threadsleep dly*1000                    ; delay seconds
                    seqrow += 1
            case 2  Koutputs = sequencer[seqrow]&0xfff
                    threadsleep dly                         ; m delay mS
                    seqrow += 1
            case 3  Koutputs = sequencer[seqrow]&0xfff
                    threadsleep dly*60000                   ; M delay Minutes
                    seqrow += 1
            case 4  Koutputs = sequencer[seqrow]&0xfff
                    if dly<597 threadsleep dly*3600000      ; H delay Hours
                    seqrow += 1
            case 5  seqrow = v2                             ; J jump to row
            case 6  stack[sp] = (seqrow+1)&0x7f             ; C call row
                    sp = (sp+1)&3
                    seqrow = v2
            case 7  Koutputs = sequencer[seqrow]&0xfff
                    threadsleep ((system.Random&0x7fffffff)//dly)*1000+1  ; U Unknown (Random) delay between 0 and dly
                    seqrow += 1
            case 8  sp = (sp-1)&3
                    seqrow = stack[sp]&0x7f                  ; X eXit subroutine (Return)
            case 9  Koutputs = sequencer[seqrow]&0xfff
                    do                                       ; T wait for HH:MM match  
                        threadsleep 500            
                    loop while v1!=Hours or v2!=Minutes             
                    seqrow += 1
            case 10 seqrow += 1
                    select v1                                ; R jump if Relay is active
                        case  0 if Rly1 seqrow = v2
                        case  1 if Rly2 seqrow = v2
                        case  2 if Rly3 seqrow = v2
                        case  3 if Rly4 seqrow = v2
                        case  4 if Rly5 seqrow = v2
                        case  5 if Rly6 seqrow = v2
                        case  6 if Rly7 seqrow = v2
                        case  7 if Rly8 seqrow = v2
                        case  8 if Rly9 seqrow = v2
                        case  9 if Rly10 seqrow = v2
                        case 10 if Rly11 seqrow = v2
                        case 11 if Rly12 seqrow = v2
                        case 12 if Rly13 seqrow = v2
                        case 13 if Rly14 seqrow = v2
                        case 14 if Rly15 seqrow = v2
                        case 15 if Rly16 seqrow = v2
                        case 16 if Rly17 seqrow = v2
                        case 17 if Rly18 seqrow = v2
                        case 18 if Rly19 seqrow = v2
                        case 19 if Rly20 seqrow = v2
                        case 20 if Rly21 seqrow = v2
                        case 21 if Rly22 seqrow = v2
                        case 22 if Rly23 seqrow = v2
                        case 23 if Rly24 seqrow = v2
                        case 24 if Rly25 seqrow = v2
                        case 25 if Rly26 seqrow = v2
                        case 26 if Rly27 seqrow = v2
                        case 27 if Rly28 seqrow = v2
                        case 28 if Rly29 seqrow = v2
                        case 29 if Rly30 seqrow = v2
                        case 30 if Rly31 seqrow = v2
                        case 31 if Rly32 seqrow = v2
                    endselect
            case 11 seqrow += 1
                    select v1                              ; D jump if I/O is active
                        case 1  if IO1 seqrow = v2
                        case 2  if IO2 seqrow = v2
                        case 3  if IO3 seqrow = v2
                        case 4  if IO4 seqrow = v2
                    endselect
            case 12 seqrow += 1
                    if SchStatus[v1&7] seqrow = v2      ; S jump if shedule is active   
            else    seqrow = 0                          ; Blamk line, default jump to first line
        endselect
    loop
endthread


thread RelayUpdate(100)
	if System_RLY_PUR&0x00000001 RelayStore[0] = Rly1		; keep eeprom updated with relay states
	if System_RLY_PUR&0x00000002 RelayStore[1] = Rly2		; note the eeprom will only actually get written on changes
	if System_RLY_PUR&0x00000004 RelayStore[2] = Rly3
	if System_RLY_PUR&0x00000008 RelayStore[3] = Rly4
	if System_RLY_PUR&0x00000010 RelayStore[4] = Rly5
	if System_RLY_PUR&0x00000020 RelayStore[5] = Rly6
	if System_RLY_PUR&0x00000040 RelayStore[6] = Rly7
	if System_RLY_PUR&0x00000080 RelayStore[7] = Rly8
	if System_RLY_PUR&0x00000100 RelayStore[8] = Rly9
	if System_RLY_PUR&0x00000200 RelayStore[9] = Rly10
	if System_RLY_PUR&0x00000400 RelayStore[10] = Rly11
	if System_RLY_PUR&0x00000800 RelayStore[11] = Rly12
	if System_RLY_PUR&0x00001000 RelayStore[12] = Rly13
	if System_RLY_PUR&0x00002000 RelayStore[13] = Rly14
	if System_RLY_PUR&0x00004000 RelayStore[14] = Rly15
	if System_RLY_PUR&0x00008000 RelayStore[15] = Rly16
	if System_RLY_PUR&0x00010000 RelayStore[16] = Rly17
	if System_RLY_PUR&0x00020000 RelayStore[17] = Rly18
	if System_RLY_PUR&0x00040000 RelayStore[18] = Rly19
	if System_RLY_PUR&0x00080000 RelayStore[19] = Rly20
	if System_RLY_PUR&0x00100000 RelayStore[20] = Rly21
	if System_RLY_PUR&0x00200000 RelayStore[21] = Rly22
	if System_RLY_PUR&0x00400000 RelayStore[22] = Rly23
	if System_RLY_PUR&0x00800000 RelayStore[23] = Rly24
	if System_RLY_PUR&0x01000000 RelayStore[24] = Rly25
	if System_RLY_PUR&0x02000000 RelayStore[25] = Rly26
	if System_RLY_PUR&0x04000000 RelayStore[26] = Rly27
	if System_RLY_PUR&0x08000000 RelayStore[27] = Rly28
	if System_RLY_PUR&0x10000000 RelayStore[28] = Rly29
	if System_RLY_PUR&0x20000000 RelayStore[29] = Rly30
	if System_RLY_PUR&0x40000000 RelayStore[30] = Rly31
	if System_RLY_PUR&0x80000000 RelayStore[31] = Rly32
endthread
		


function ScheduleArrayInit()
	SchStartA[1] = (System_Sch_STH1a*3600) + (System_Sch_STM1a*60) + System_Sch_STS1a
	SchStopA[1] = (System_Sch_SPH1a*3600) + (System_Sch_SPM1a*60) + System_Sch_SPS1a
	SchStartB[1] = (System_Sch_STH1b*3600) + (System_Sch_STM1b*60) + System_Sch_STS1b
	SchStopB[1] = (System_Sch_SPH1b*3600) + (System_Sch_SPM1b*60) + System_Sch_SPS1b
	SchWDay[1] = System_Sch_WD1&0x7f
	SchRelays[1] = System_Sch_R1
	
	SchStartA[2] = (System_Sch_STH2a*3600) + (System_Sch_STM2a*60) + System_Sch_STS2a
	SchStopA[2] = (System_Sch_SPH2a*3600) + (System_Sch_SPM2a*60) + System_Sch_SPS2a
	SchStartB[2] = (System_Sch_STH2b*3600) + (System_Sch_STM2b*60) + System_Sch_STS2b
	SchStopB[2] = (System_Sch_SPH2b*3600) + (System_Sch_SPM2b*60) + System_Sch_SPS2b
	SchWDay[2] = System_Sch_WD2&0x7f
	SchRelays[2] = System_Sch_R2
	
	SchStartA[3] = (System_Sch_STH3a*3600) + (System_Sch_STM3a*60) + System_Sch_STS3a
	SchStopA[3] = (System_Sch_SPH3a*3600) + (System_Sch_SPM3a*60) + System_Sch_SPS3a
	SchStartB[3] = (System_Sch_STH3b*3600) + (System_Sch_STM3b*60) + System_Sch_STS3b
	SchStopB[3] = (System_Sch_SPH3b*3600) + (System_Sch_SPM3b*60) + System_Sch_SPS3b
	SchWDay[3] = System_Sch_WD3&0x7f
	SchRelays[3] = System_Sch_R3
	
	SchStartA[4] = (System_Sch_STH4a*3600) + (System_Sch_STM4a*60) + System_Sch_STS4a
	SchStopA[4] = (System_Sch_SPH4a*3600) + (System_Sch_SPM4a*60) + System_Sch_SPS4a
	SchStartB[4] = (System_Sch_STH4b*3600) + (System_Sch_STM4b*60) + System_Sch_STS4b
	SchStopB[4] = (System_Sch_SPH4b*3600) + (System_Sch_SPM4b*60) + System_Sch_SPS4b
	SchWDay[4] = System_Sch_WD4&0x7f
	SchRelays[4] = System_Sch_R4
	
	SchStartA[5] = (System_Sch_STH5a*3600) + (System_Sch_STM5a*60) + System_Sch_STS5a
	SchStopA[5] = (System_Sch_SPH5a*3600) + (System_Sch_SPM5a*60) + System_Sch_SPS5a
	SchStartB[5] = (System_Sch_STH5b*3600) + (System_Sch_STM5b*60) + System_Sch_STS5b
	SchStopB[5] = (System_Sch_SPH5b*3600) + (System_Sch_SPM5b*60) + System_Sch_SPS5b
	SchWDay[5] = System_Sch_WD5&0x7f
	SchRelays[5] = System_Sch_R5
	
	SchStartA[6] = (System_Sch_STH6a*3600) + (System_Sch_STM6a*60) + System_Sch_STS6a
	SchStopA[6] = (System_Sch_SPH6a*3600) + (System_Sch_SPM6a*60) + System_Sch_SPS6a
	SchStartB[6] = (System_Sch_STH6b*3600) + (System_Sch_STM6b*60) + System_Sch_STS6b
	SchStopB[6] = (System_Sch_SPH6b*3600) + (System_Sch_SPM6b*60) + System_Sch_SPS6b
	SchWDay[6] = System_Sch_WD6&0x7f
	SchRelays[6] = System_Sch_R6
	
	SchStartA[7] = (System_Sch_STH7a*3600) + (System_Sch_STM7a*60) + System_Sch_STS7a
	SchStopA[7] = (System_Sch_SPH7a*3600) + (System_Sch_SPM7a*60) + System_Sch_SPS7a
	SchStartB[7] = (System_Sch_STH7b*3600) + (System_Sch_STM7b*60) + System_Sch_STS7b
	SchStopB[7] = (System_Sch_SPH7b*3600) + (System_Sch_SPM7b*60) + System_Sch_SPS7b
	SchWDay[7] = System_Sch_WD7&0x7f
	SchRelays[7] = System_Sch_R7
		
	SchStartA[8] = (System_Sch_STH8a*3600) + (System_Sch_STM8a*60) + System_Sch_STS8a
	SchStopA[8] = (System_Sch_SPH8a*3600) + (System_Sch_SPM8a*60) + System_Sch_SPS8a
	SchStartB[8] = (System_Sch_STH8b*3600) + (System_Sch_STM8b*60) + System_Sch_STS8b
	SchStopB[8] = (System_Sch_SPH8b*3600) + (System_Sch_SPM8b*60) + System_Sch_SPS8b
	SchWDay[8] = System_Sch_WD8&0x7f
	SchRelays[8] = System_Sch_R8
	return
endfunction
	
thread RunBooleanProcesses(const)
	ScheduleArrayInit()
	do
		if system.FlashPending ScheduleArrayInit()	; re-init if user changed something
		
		if System_Rly1Bool.IsBool() then Rly1 = System_Rly1Bool.BooleanEval()		; Relay 1
		else 
			if System_Rly1Set.IsBool() then
				RlySetTrn[1] <<= 1
				if System_Rly1Set.BooleanEval() RlySetTrn[1] |= 0x01
				if RlySetTrn[1] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly1Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly1Thread
					else Rly1 = on
					endif
				endif
			endif
			if System_Rly1Rst.IsBool() then
				RlyRstTrn[1] <<= 1
				if System_Rly1Rst.BooleanEval() RlyRstTrn[1] |= 0x01
				if RlyRstTrn[1] == 0x01 Rly1 = off
			endif
			if System_Rly1Tog.IsBool() then
				RlyTogTrn[1] <<= 1
				if System_Rly1Tog.BooleanEval() RlyTogTrn[1] |= 0x01
				if RlyTogTrn[1] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly1Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly1Thread
					else Rly1 = Rly1^0x01
					endif
				endif
			endif
		endif

		if System_Rly2Bool.IsBool() then Rly2 = System_Rly2Bool.BooleanEval()		; Relay 2
		else 
			if System_Rly2Set.IsBool() then
				RlySetTrn[2] <<= 1
				if System_Rly2Set.BooleanEval() RlySetTrn[2] |= 0x01
				if RlySetTrn[2] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly2Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly2Thread
					else Rly2 = on
					endif
				endif
			endif
			if System_Rly2Rst.IsBool() then
				RlyRstTrn[2] <<= 1
				if System_Rly2Rst.BooleanEval() RlyRstTrn[2] |= 0x01
				if RlyRstTrn[2] == 0x01 Rly2 = off
			endif
			if System_Rly2Tog.IsBool() then
				RlyTogTrn[2] <<= 1
				if System_Rly2Tog.BooleanEval() RlyTogTrn[2] |= 0x01
				if RlyTogTrn[2] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly2Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly2Thread
					else Rly2 = Rly2^0x01
					endif
				endif
			endif
		endif	
			
		if System_Rly3Bool.IsBool() then Rly3 = System_Rly3Bool.BooleanEval()		; Relay 3
		else 
			if System_Rly3Set.IsBool() then
				RlySetTrn[3] <<= 1
				if System_Rly3Set.BooleanEval() RlySetTrn[3] |= 0x01
				if RlySetTrn[3] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly3Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly3Thread
					else Rly3 = on
					endif
				endif
			endif
			if System_Rly3Rst.IsBool() then
				RlyRstTrn[3] <<= 1
				if System_Rly3Rst.BooleanEval() RlyRstTrn[3] |= 0x01
				if RlyRstTrn[3] == 0x01 Rly3 = off
			endif
			if System_Rly3Tog.IsBool() then
				RlyTogTrn[3] <<= 1
				if System_Rly3Tog.BooleanEval() RlyTogTrn[3] |= 0x01
				if RlyTogTrn[3] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly3Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly3Thread
					else Rly3 = Rly3^0x01
					endif
				endif
			endif
		endif		

		if System_Rly4Bool.IsBool() then Rly4 = System_Rly4Bool.BooleanEval()		; Relay 4
		else 
			if System_Rly4Set.IsBool() then
				RlySetTrn[4] <<= 1
				if System_Rly4Set.BooleanEval() RlySetTrn[4] |= 0x01
				if RlySetTrn[4] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly4Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly4Thread
					else Rly4 = on
					endif
				endif
			endif
			if System_Rly4Rst.IsBool() then
				RlyRstTrn[4] <<= 1
				if System_Rly4Rst.BooleanEval() RlyRstTrn[4] |= 0x01
				if RlyRstTrn[4] == 0x01 Rly4 = off
			endif
			if System_Rly4Tog.IsBool() then
				RlyTogTrn[4] <<= 1
				if System_Rly4Tog.BooleanEval() RlyTogTrn[4] |= 0x01
				if RlyTogTrn[4] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly4Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly4Thread
					else Rly4 = Rly4^0x01
					endif
				endif
			endif
		endif

		if System_Rly5Bool.IsBool() then Rly5 = System_Rly5Bool.BooleanEval()		; Relay 5
		else 
			if System_Rly5Set.IsBool() then
				RlySetTrn[5] <<= 1
				if System_Rly5Set.BooleanEval() RlySetTrn[5] |= 0x01
				if RlySetTrn[5] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly5Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly5Thread
					else Rly5 = on
					endif
				endif

			endif
			if System_Rly5Rst.IsBool() then
				RlyRstTrn[5] <<= 1
				if System_Rly5Rst.BooleanEval() RlyRstTrn[5] |= 0x01
				if RlyRstTrn[5] == 0x01 Rly5 = off
			endif
			if System_Rly5Tog.IsBool() then
				RlyTogTrn[5] <<= 1
				if System_Rly5Tog.BooleanEval() RlyTogTrn[5] |= 0x01
				if RlyTogTrn[5] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly5Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly5Thread
					else Rly5 = Rly5^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly6Bool.IsBool() then Rly6 = System_Rly6Bool.BooleanEval()		; Relay 6
		else 
			if System_Rly6Set.IsBool() then
				RlySetTrn[6] <<= 1
				if System_Rly6Set.BooleanEval() RlySetTrn[6] |= 0x01
				if RlySetTrn[6] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly6Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly6Thread
					else Rly6 = on
					endif
				endif
			endif
			if System_Rly6Rst.IsBool() then
				RlyRstTrn[6] <<= 1
				if System_Rly6Rst.BooleanEval() RlyRstTrn[6] |= 0x01
				if RlyRstTrn[6] == 0x01 Rly6 = off
			endif
			if System_Rly6Tog.IsBool() then
				RlyTogTrn[6] <<= 1
				if System_Rly6Tog.BooleanEval() RlyTogTrn[6] |= 0x01
				if RlyTogTrn[6] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly6Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly6Thread
					else Rly6 = Rly6^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly7Bool.IsBool() then Rly7 = System_Rly7Bool.BooleanEval()		; Relay 7
		else 
			if System_Rly7Set.IsBool() then
				RlySetTrn[7] <<= 1
				if System_Rly7Set.BooleanEval() RlySetTrn[7] |= 0x01
				if RlySetTrn[7] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly7Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly7Thread
					else Rly7 = on
					endif
				endif
			endif
			if System_Rly7Rst.IsBool() then
				RlyRstTrn[7] <<= 1
				if System_Rly7Rst.BooleanEval() RlyRstTrn[7] |= 0x01
				if RlyRstTrn[7] == 0x01 Rly7 = off
			endif
			if System_Rly7Tog.IsBool() then
				RlyTogTrn[7] <<= 1
				if System_Rly7Tog.BooleanEval() RlyTogTrn[7] |= 0x01
				if RlyTogTrn[7] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly7Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly7Thread
					else Rly7 = Rly7^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly8Bool.IsBool() then Rly8 = System_Rly8Bool.BooleanEval()		; Relay 8
		else 
			if System_Rly8Set.IsBool() then
				RlySetTrn[8] <<= 1
				if System_Rly8Set.BooleanEval() RlySetTrn[8] |= 0x01
				if RlySetTrn[8] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly8Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly8Thread
					else Rly8 = on
					endif
				endif
			endif
			if System_Rly8Rst.IsBool() then
				RlyRstTrn[8] <<= 1
				if System_Rly8Rst.BooleanEval() RlyRstTrn[8] |= 0x01
				if RlyRstTrn[8] == 0x01 Rly8 = off
			endif
			if System_Rly8Tog.IsBool() then
				RlyTogTrn[8] <<= 1
				if System_Rly8Tog.BooleanEval() RlyTogTrn[8] |= 0x01
				if RlyTogTrn[8] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly8Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly8Thread
					else Rly8 = Rly8^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly9Bool.IsBool() then Rly9 = System_Rly9Bool.BooleanEval()		; Relay 9
		else 
			if System_Rly9Set.IsBool() then
				RlySetTrn[9] <<= 1
				if System_Rly9Set.BooleanEval() RlySetTrn[9] |= 0x01
				if RlySetTrn[9] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly9Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly9Thread
					else Rly9 = on
					endif
				endif
			endif
			if System_Rly9Rst.IsBool() then
				RlyRstTrn[9] <<= 1
				if System_Rly9Rst.BooleanEval() RlyRstTrn[9] |= 0x01
				if RlyRstTrn[9] == 0x01 Rly9 = off
			endif
			if System_Rly9Tog.IsBool() then
				RlyTogTrn[9] <<= 1
				if System_Rly9Tog.BooleanEval() RlyTogTrn[9] |= 0x01
				if RlyTogTrn[9] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly9Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly9Thread
					else Rly9 = Rly9^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly10Bool.IsBool() then Rly10 = System_Rly10Bool.BooleanEval()		; Relay 10
		else 
			if System_Rly10Set.IsBool() then
				RlySetTrn[10] <<= 1
				if System_Rly10Set.BooleanEval() RlySetTrn[10] |= 0x01
				if RlySetTrn[10] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly10Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly10Thread
					else Rly10 = on
					endif
				endif
			endif
			if System_Rly10Rst.IsBool() then
				RlyRstTrn[10] <<= 1
				if System_Rly10Rst.BooleanEval() RlyRstTrn[10] |= 0x01
				if RlyRstTrn[10] == 0x01 Rly10 = off
			endif
			if System_Rly10Tog.IsBool() then
				RlyTogTrn[10] <<= 1
				if System_Rly10Tog.BooleanEval() RlyTogTrn[10] |= 0x01
				if RlyTogTrn[10] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly10Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly10Thread
					else Rly10 = Rly10^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly11Bool.IsBool() then Rly11 = System_Rly11Bool.BooleanEval()		; Relay 11
		else 
			if System_Rly11Set.IsBool() then
				RlySetTrn[11] <<= 1
				if System_Rly11Set.BooleanEval() RlySetTrn[11] |= 0x01
				if RlySetTrn[11] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly11Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly11Thread
					else Rly11 = on
					endif
				endif
			endif
			if System_Rly11Rst.IsBool() then
				RlyRstTrn[11] <<= 1
				if System_Rly11Rst.BooleanEval() RlyRstTrn[11] |= 0x01
				if RlyRstTrn[11] == 0x01 Rly11 = off
			endif
			if System_Rly11Tog.IsBool() then
				RlyTogTrn[11] <<= 1
				if System_Rly11Tog.BooleanEval() RlyTogTrn[11] |= 0x01
				if RlyTogTrn[11] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly11Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly11Thread
					else Rly11 = Rly11^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly12Bool.IsBool() then Rly12 = System_Rly12Bool.BooleanEval()		; Relay 12
		else 
			if System_Rly12Set.IsBool() then
				RlySetTrn[12] <<= 1
				if System_Rly12Set.BooleanEval() RlySetTrn[12] |= 0x01
				if RlySetTrn[12] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly12Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly12Thread
					else Rly12 = on
					endif
				endif
			endif
			if System_Rly12Rst.IsBool() then
				RlyRstTrn[12] <<= 1
				if System_Rly12Rst.BooleanEval() RlyRstTrn[12] |= 0x01
				if RlyRstTrn[12] == 0x01 Rly12 = off
			endif
			if System_Rly12Tog.IsBool() then
				RlyTogTrn[12] <<= 1
				if System_Rly12Tog.BooleanEval() RlyTogTrn[12] |= 0x01
				if RlyTogTrn[12] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly12Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly12Thread
					else Rly12 = Rly12^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly13Bool.IsBool() then Rly13 = System_Rly13Bool.BooleanEval()		; Relay 13
		else 
			if System_Rly13Set.IsBool() then
				RlySetTrn[13] <<= 1
				if System_Rly13Set.BooleanEval() RlySetTrn[13] |= 0x01
				if RlySetTrn[13] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly13Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly13Thread
					else Rly13 = on
					endif
				endif
			endif
			if System_Rly13Rst.IsBool() then
				RlyRstTrn[13] <<= 1
				if System_Rly13Rst.BooleanEval() RlyRstTrn[13] |= 0x01
				if RlyRstTrn[13] == 0x01 Rly13 = off
			endif
			if System_Rly13Tog.IsBool() then
				RlyTogTrn[13] <<= 1
				if System_Rly13Tog.BooleanEval() RlyTogTrn[13] |= 0x01
				if RlyTogTrn[13] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly13Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly13Thread
					else Rly13 = Rly13^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly14Bool.IsBool() then Rly14 = System_Rly14Bool.BooleanEval()		; Relay 14
		else 
			if System_Rly14Set.IsBool() then
				RlySetTrn[14] <<= 1
				if System_Rly14Set.BooleanEval() RlySetTrn[14] |= 0x01
				if RlySetTrn[14] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly14Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly14Thread
					else Rly14 = on
					endif
				endif
			endif
			if System_Rly14Rst.IsBool() then
				RlyRstTrn[14] <<= 1
				if System_Rly14Rst.BooleanEval() RlyRstTrn[14] |= 0x01
				if RlyRstTrn[14] == 0x01 Rly14 = off
			endif
			if System_Rly14Tog.IsBool() then
				RlyTogTrn[14] <<= 1
				if System_Rly14Tog.BooleanEval() RlyTogTrn[14] |= 0x01
				if RlyTogTrn[14] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly14Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly14Thread
					else Rly14 = Rly14^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly15Bool.IsBool() then Rly15 = System_Rly15Bool.BooleanEval()		; Relay 15
		else 
			if System_Rly15Set.IsBool() then
				RlySetTrn[15] <<= 1
				if System_Rly15Set.BooleanEval() RlySetTrn[15] |= 0x01
				if RlySetTrn[15] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly15Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly15Thread
					else Rly15 = on
					endif
				endif
			endif
			if System_Rly15Rst.IsBool() then
				RlyRstTrn[15] <<= 1
				if System_Rly15Rst.BooleanEval() RlyRstTrn[15] |= 0x01
				if RlyRstTrn[15] == 0x01 Rly15 = off
			endif
			if System_Rly15Tog.IsBool() then
				RlyTogTrn[15] <<= 1
				if System_Rly15Tog.BooleanEval() RlyTogTrn[15] |= 0x01
				if RlyTogTrn[15] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly15Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly15Thread
					else Rly15 = Rly15^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly16Bool.IsBool() then Rly16 = System_Rly16Bool.BooleanEval()		; Relay 16
		else 
			if System_Rly16Set.IsBool() then
				RlySetTrn[16] <<= 1
				if System_Rly16Set.BooleanEval() RlySetTrn[16] |= 0x01
				if RlySetTrn[16] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly16Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly16Thread
					else Rly16 = on
					endif
				endif
			endif
			if System_Rly16Rst.IsBool() then
				RlyRstTrn[16] <<= 1
				if System_Rly16Rst.BooleanEval() RlyRstTrn[16] |= 0x01
				if RlyRstTrn[16] == 0x01 Rly16 = off
			endif
			if System_Rly16Tog.IsBool() then
				RlyTogTrn[16] <<= 1
				if System_Rly16Tog.BooleanEval() RlyTogTrn[16] |= 0x01
				if RlyTogTrn[16] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly16Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly16Thread
					else Rly16 = Rly16^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly17Bool.IsBool() then Rly17 = System_Rly17Bool.BooleanEval()		; Relay 17
		else 
			if System_Rly17Set.IsBool() then
				RlySetTrn[17] <<= 1
				if System_Rly17Set.BooleanEval() RlySetTrn[17] |= 0x01
				if RlySetTrn[17] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly17Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly17Thread
					else Rly17 = on
					endif
				endif
			endif
			if System_Rly17Rst.IsBool() then
				RlyRstTrn[17] <<= 1
				if System_Rly17Rst.BooleanEval() RlyRstTrn[17] |= 0x01
				if RlyRstTrn[17] == 0x01 Rly17 = off
			endif
			if System_Rly17Tog.IsBool() then
				RlyTogTrn[17] <<= 1
				if System_Rly17Tog.BooleanEval() RlyTogTrn[17] |= 0x01
				if RlyTogTrn[17] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly17Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly17Thread
					else Rly17 = Rly17^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly18Bool.IsBool() then Rly18 = System_Rly18Bool.BooleanEval()		; Relay 18
		else 
			if System_Rly18Set.IsBool() then
				RlySetTrn[18] <<= 1
				if System_Rly18Set.BooleanEval() RlySetTrn[18] |= 0x01
				if RlySetTrn[18] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly18Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly18Thread
					else Rly18 = on
					endif
				endif
			endif
			if System_Rly18Rst.IsBool() then
				RlyRstTrn[18] <<= 1
				if System_Rly18Rst.BooleanEval() RlyRstTrn[18] |= 0x01
				if RlyRstTrn[18] == 0x01 Rly18 = off
			endif
			if System_Rly18Tog.IsBool() then
				RlyTogTrn[18] <<= 1
				if System_Rly18Tog.BooleanEval() RlyTogTrn[18] |= 0x01
				if RlyTogTrn[18] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly18Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly18Thread
					else Rly18 = Rly18^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly19Bool.IsBool() then Rly19 = System_Rly19Bool.BooleanEval()		; Relay 19
		else 
			if System_Rly19Set.IsBool() then
				RlySetTrn[19] <<= 1
				if System_Rly19Set.BooleanEval() RlySetTrn[19] |= 0x01
				if RlySetTrn[19] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly19Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly19Thread
					else Rly19 = on
					endif
				endif
			endif
			if System_Rly19Rst.IsBool() then
				RlyRstTrn[19] <<= 1
				if System_Rly19Rst.BooleanEval() RlyRstTrn[19] |= 0x01
				if RlyRstTrn[19] == 0x01 Rly19 = off
			endif
			if System_Rly19Tog.IsBool() then
				RlyTogTrn[19] <<= 1
				if System_Rly19Tog.BooleanEval() RlyTogTrn[19] |= 0x01
				if RlyTogTrn[19] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly19Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly19Thread
					else Rly19 = Rly19^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly20Bool.IsBool() then Rly20 = System_Rly20Bool.BooleanEval()		; Relay 20
		else 
			if System_Rly20Set.IsBool() then
				RlySetTrn[20] <<= 1
				if System_Rly20Set.BooleanEval() RlySetTrn[20] |= 0x01
				if RlySetTrn[20] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly20Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly20Thread
					else Rly20 = on
					endif
				endif
			endif
			if System_Rly20Rst.IsBool() then
				RlyRstTrn[20] <<= 1
				if System_Rly20Rst.BooleanEval() RlyRstTrn[20] |= 0x01
				if RlyRstTrn[20] == 0x01 Rly20 = off
			endif
			if System_Rly20Tog.IsBool() then
				RlyTogTrn[20] <<= 1
				if System_Rly20Tog.BooleanEval() RlyTogTrn[20] |= 0x01
				if RlyTogTrn[20] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly20Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly20Thread
					else Rly20 = Rly20^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly21Bool.IsBool() then Rly21 = System_Rly21Bool.BooleanEval()		; Relay 21
		else 
			if System_Rly21Set.IsBool() then
				RlySetTrn[21] <<= 1
				if System_Rly21Set.BooleanEval() RlySetTrn[21] |= 0x01
				if RlySetTrn[21] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly21Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly21Thread
					else Rly21 = on
					endif
				endif
			endif
			if System_Rly21Rst.IsBool() then
				RlyRstTrn[21] <<= 1
				if System_Rly21Rst.BooleanEval() RlyRstTrn[21] |= 0x01
				if RlyRstTrn[21] == 0x01 Rly21 = off
			endif
			if System_Rly21Tog.IsBool() then
				RlyTogTrn[21] <<= 1
				if System_Rly21Tog.BooleanEval() RlyTogTrn[21] |= 0x01
				if RlyTogTrn[21] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly21Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly21Thread
					else Rly21 = Rly21^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly22Bool.IsBool() then Rly22 = System_Rly22Bool.BooleanEval()		; Relay 22
		else 
			if System_Rly22Set.IsBool() then
				RlySetTrn[22] <<= 1
				if System_Rly22Set.BooleanEval() RlySetTrn[22] |= 0x01
				if RlySetTrn[22] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly22Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly22Thread
					else Rly22 = on
					endif
				endif
			endif
			if System_Rly22Rst.IsBool() then
				RlyRstTrn[22] <<= 1
				if System_Rly22Rst.BooleanEval() RlyRstTrn[22] |= 0x01
				if RlyRstTrn[22] == 0x01 Rly22 = off
			endif
			if System_Rly22Tog.IsBool() then
				RlyTogTrn[22] <<= 1
				if System_Rly22Tog.BooleanEval() RlyTogTrn[22] |= 0x01
				if RlyTogTrn[22] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly22Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly22Thread
					else Rly22 = Rly22^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly23Bool.IsBool() then Rly23 = System_Rly23Bool.BooleanEval()		; Relay 23
		else 
			if System_Rly23Set.IsBool() then
				RlySetTrn[23] <<= 1
				if System_Rly23Set.BooleanEval() RlySetTrn[23] |= 0x01
				if RlySetTrn[23] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly23Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly23Thread
					else Rly23 = on
					endif
				endif
			endif
			if System_Rly23Rst.IsBool() then
				RlyRstTrn[23] <<= 1
				if System_Rly23Rst.BooleanEval() RlyRstTrn[23] |= 0x01
				if RlyRstTrn[23] == 0x01 Rly23 = off
			endif
			if System_Rly23Tog.IsBool() then
				RlyTogTrn[23] <<= 1
				if System_Rly23Tog.BooleanEval() RlyTogTrn[23] |= 0x01
				if RlyTogTrn[23] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly23Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly23Thread
					else Rly23 = Rly23^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly24Bool.IsBool() then Rly24 = System_Rly24Bool.BooleanEval()		; Relay 24
		else 
			if System_Rly24Set.IsBool() then
				RlySetTrn[24] <<= 1
				if System_Rly24Set.BooleanEval() RlySetTrn[24] |= 0x01
				if RlySetTrn[24] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly24Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly24Thread
					else Rly24 = on
					endif
				endif
			endif
			if System_Rly24Rst.IsBool() then
				RlyRstTrn[24] <<= 1
				if System_Rly24Rst.BooleanEval() RlyRstTrn[24] |= 0x01
				if RlyRstTrn[24] == 0x01 Rly24 = off
			endif
			if System_Rly24Tog.IsBool() then
				RlyTogTrn[24] <<= 1
				if System_Rly24Tog.BooleanEval() RlyTogTrn[24] |= 0x01
				if RlyTogTrn[24] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly24Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly24Thread
					else Rly24 = Rly24^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly25Bool.IsBool() then Rly25 = System_Rly25Bool.BooleanEval()		; Relay 25
		else 
			if System_Rly25Set.IsBool() then
				RlySetTrn[25] <<= 1
				if System_Rly25Set.BooleanEval() RlySetTrn[25] |= 0x01
				if RlySetTrn[25] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly25Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly25Thread
					else Rly25 = on
					endif
				endif
			endif
			if System_Rly25Rst.IsBool() then
				RlyRstTrn[25] <<= 1
				if System_Rly25Rst.BooleanEval() RlyRstTrn[25] |= 0x01
				if RlyRstTrn[25] == 0x01 Rly25 = off
			endif
			if System_Rly25Tog.IsBool() then
				RlyTogTrn[25] <<= 1
				if System_Rly25Tog.BooleanEval() RlyTogTrn[25] |= 0x01
				if RlyTogTrn[25] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly25Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly25Thread
					else Rly25 = Rly25^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly26Bool.IsBool() then Rly26 = System_Rly26Bool.BooleanEval()		; Relay 26
		else 
			if System_Rly26Set.IsBool() then
				RlySetTrn[26] <<= 1
				if System_Rly26Set.BooleanEval() RlySetTrn[26] |= 0x01
				if RlySetTrn[26] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly26Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly26Thread
					else Rly26 = on
					endif
				endif
			endif
			if System_Rly26Rst.IsBool() then
				RlyRstTrn[26] <<= 1
				if System_Rly26Rst.BooleanEval() RlyRstTrn[26] |= 0x01
				if RlyRstTrn[26] == 0x01 Rly26 = off
			endif
			if System_Rly26Tog.IsBool() then
				RlyTogTrn[26] <<= 1
				if System_Rly26Tog.BooleanEval() RlyTogTrn[26] |= 0x01
				if RlyTogTrn[26] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly26Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly26Thread
					else Rly26 = Rly26^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly27Bool.IsBool() then Rly27 = System_Rly27Bool.BooleanEval()		; Relay 27
		else 
			if System_Rly27Set.IsBool() then
				RlySetTrn[27] <<= 1
				if System_Rly27Set.BooleanEval() RlySetTrn[27] |= 0x01
				if RlySetTrn[27] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly27Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly27Thread
					else Rly27 = on
					endif
				endif
			endif
			if System_Rly27Rst.IsBool() then
				RlyRstTrn[27] <<= 1
				if System_Rly27Rst.BooleanEval() RlyRstTrn[27] |= 0x01
				if RlyRstTrn[27] == 0x01 Rly27 = off
			endif
			if System_Rly27Tog.IsBool() then
				RlyTogTrn[27] <<= 1
				if System_Rly27Tog.BooleanEval() RlyTogTrn[27] |= 0x01
				if RlyTogTrn[27] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly27Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly27Thread
					else Rly27 = Rly27^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly28Bool.IsBool() then Rly28 = System_Rly28Bool.BooleanEval()		; Relay 28
		else 
			if System_Rly28Set.IsBool() then
				RlySetTrn[28] <<= 1
				if System_Rly28Set.BooleanEval() RlySetTrn[28] |= 0x01
				if RlySetTrn[28] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly28Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly28Thread
					else Rly28 = on
					endif
				endif
			endif
			if System_Rly28Rst.IsBool() then
				RlyRstTrn[28] <<= 1
				if System_Rly28Rst.BooleanEval() RlyRstTrn[28] |= 0x01
				if RlyRstTrn[28] == 0x01 Rly28 = off
			endif
			if System_Rly28Tog.IsBool() then
				RlyTogTrn[28] <<= 1
				if System_Rly28Tog.BooleanEval() RlyTogTrn[28] |= 0x01
				if RlyTogTrn[28] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly28Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly28Thread
					else Rly28 = Rly28^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly29Bool.IsBool() then Rly29 = System_Rly29Bool.BooleanEval()		; Relay 29
		else 
			if System_Rly29Set.IsBool() then
				RlySetTrn[29] <<= 1
				if System_Rly29Set.BooleanEval() RlySetTrn[29] |= 0x01
				if RlySetTrn[29] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly29Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly29Thread
					else Rly29 = on
					endif
				endif
			endif
			if System_Rly29Rst.IsBool() then
				RlyRstTrn[29] <<= 1
				if System_Rly29Rst.BooleanEval() RlyRstTrn[29] |= 0x01
				if RlyRstTrn[29] == 0x01 Rly29 = off
			endif
			if System_Rly29Tog.IsBool() then
				RlyTogTrn[29] <<= 1
				if System_Rly29Tog.BooleanEval() RlyTogTrn[29] |= 0x01
				if RlyTogTrn[29] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly29Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly29Thread
					else Rly29 = Rly29^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly30Bool.IsBool() then Rly30 = System_Rly30Bool.BooleanEval()		; Relay 30
		else 
			if System_Rly30Set.IsBool() then
				RlySetTrn[30] <<= 1
				if System_Rly30Set.BooleanEval() RlySetTrn[30] |= 0x01
				if RlySetTrn[30] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly30Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly30Thread
					else Rly30 = on
					endif
				endif
			endif
			if System_Rly30Rst.IsBool() then
				RlyRstTrn[30] <<= 1
				if System_Rly30Rst.BooleanEval() RlyRstTrn[30] |= 0x01
				if RlyRstTrn[30] == 0x01 Rly30 = off
			endif
			if System_Rly30Tog.IsBool() then
				RlyTogTrn[30] <<= 1
				if System_Rly30Tog.BooleanEval() RlyTogTrn[30] |= 0x01
				if RlyTogTrn[30] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly30Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly30Thread
					else Rly30 = Rly30^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly31Bool.IsBool() then Rly31 = System_Rly31Bool.BooleanEval()		; Relay 31
		else 
			if System_Rly31Set.IsBool() then
				RlySetTrn[31] <<= 1
				if System_Rly31Set.BooleanEval() RlySetTrn[31] |= 0x01
				if RlySetTrn[31] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly31Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly31Thread
					else Rly31 = on
					endif
				endif
			endif
			if System_Rly31Rst.IsBool() then
				RlyRstTrn[31] <<= 1
				if System_Rly31Rst.BooleanEval() RlyRstTrn[31] |= 0x01
				if RlyRstTrn[31] == 0x01 Rly31 = off
			endif
			if System_Rly31Tog.IsBool() then
				RlyTogTrn[31] <<= 1
				if System_Rly31Tog.BooleanEval() RlyTogTrn[31] |= 0x01
				if RlyTogTrn[31] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly31Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly31Thread
					else Rly31 = Rly31^0x01
					endif
				endif
			endif
		endif
		
		if System_Rly32Bool.IsBool() then Rly32 = System_Rly32Bool.BooleanEval()		; Relay 32
		else 
			if System_Rly32Set.IsBool() then
				RlySetTrn[32] <<= 1
				if System_Rly32Set.BooleanEval() RlySetTrn[32] |= 0x01
				if RlySetTrn[32] == 0x01 then 
					Zero = 0		
					PulseTime=System_Rly32Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly32Thread
					else Rly32 = on
					endif
				endif
			endif
			if System_Rly32Rst.IsBool() then
				RlyRstTrn[32] <<= 1
				if System_Rly32Rst.BooleanEval() RlyRstTrn[32] |= 0x01
				if RlyRstTrn[32] == 0x01 Rly32 = off
			endif
			if System_Rly32Tog.IsBool() then
				RlyTogTrn[32] <<= 1
				if System_Rly32Tog.BooleanEval() RlyTogTrn[32] |= 0x01
				if RlyTogTrn[32] == 0x01 then
					Zero = 0		
					PulseTime=System_Rly32Bool.GetNumAscii(Zero)						
					if PulseTime>MinRelayPulse then threadstart Rly32Thread
					else Rly32 = Rly32^0x01
					endif
				endif
			endif
		endif

		if SystemRlysUpdated then
			Zero = 0
			select SystemRlysUpdated
				case 1	if System_Rly1Bool.IsBool()==0 then 
							PulseTime=System_Rly1Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly1Thread
							else if Rly1 then Rly1=off else Rly1=on endif endif
						endif
				case 2	if System_Rly2Bool.IsBool()==0 then 
							PulseTime=System_Rly2Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly2Thread
							else if Rly2 then Rly2=off else Rly2=on endif endif
						endif
				case 3	if System_Rly3Bool.IsBool()==0 then 
							PulseTime=System_Rly3Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly3Thread
							else if Rly3 then Rly3=off else Rly3=on endif endif
						endif
				case 4	if System_Rly4Bool.IsBool()==0 then 
							PulseTime=System_Rly4Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly4Thread
							else if Rly4 then Rly4=off else Rly4=on endif endif
						endif
				case 5	if System_Rly5Bool.IsBool()==0 then 
							PulseTime=System_Rly5Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly5Thread
							else if Rly5 then Rly5=off else Rly5=on endif endif
						endif
				case 6	if System_Rly6Bool.IsBool()==0 then 
							PulseTime=System_Rly6Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly6Thread
							else if Rly6 then Rly6=off else Rly6=on endif endif
						endif
				case 7	if System_Rly7Bool.IsBool()==0 then 
							PulseTime=System_Rly7Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly7Thread
							else if Rly7 then Rly7=off else Rly7=on endif endif
						endif
				case 8	if System_Rly8Bool.IsBool()==0 then 
							PulseTime=System_Rly8Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly8Thread
							else if Rly8 then Rly8=off else Rly8=on endif endif
						endif
				case 9	if System_Rly9Bool.IsBool()==0 then 
							PulseTime=System_Rly9Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly9Thread
							else if Rly9 then Rly9=off else Rly9=on endif endif
						endif
				case 10	if System_Rly10Bool.IsBool()==0 then 
							PulseTime=System_Rly10Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly10Thread
							else if Rly10 then Rly10=off else Rly10=on endif endif
						endif
				case 11	if System_Rly11Bool.IsBool()==0 then 
							PulseTime=System_Rly11Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly11Thread
							else if Rly11 then Rly11=off else Rly11=on endif endif
						endif
				case 12	if System_Rly12Bool.IsBool()==0 then 
							PulseTime=System_Rly12Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly12Thread
							else if Rly12 then Rly12=off else Rly12=on endif endif
						endif
				case 13	if System_Rly13Bool.IsBool()==0 then 
							PulseTime=System_Rly13Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly13Thread
							else if Rly13 then Rly13=off else Rly13=on endif endif
						endif
				case 14	if System_Rly14Bool.IsBool()==0 then 
							PulseTime=System_Rly14Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly14Thread
							else if Rly14 then Rly14=off else Rly14=on endif endif
						endif
				case 15	if System_Rly15Bool.IsBool()==0 then 
							PulseTime=System_Rly15Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly15Thread
							else if Rly15 then Rly15=off else Rly15=on endif endif
						endif
				case 16	if System_Rly16Bool.IsBool()==0 then 
							PulseTime=System_Rly16Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly16Thread
							else if Rly16 then Rly16=off else Rly16=on endif endif
						endif
				case 17	if System_Rly17Bool.IsBool()==0 then 
							PulseTime=System_Rly17Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly17Thread
							else if Rly17 then Rly17=off else Rly17=on endif endif
						endif
				case 18	if System_Rly18Bool.IsBool()==0 then 
							PulseTime=System_Rly18Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly18Thread
							else if Rly18 then Rly18=off else Rly18=on endif endif
						endif
				case 19	if System_Rly19Bool.IsBool()==0 then 
							PulseTime=System_Rly19Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly19Thread
							else if Rly19 then Rly19=off else Rly19=on endif endif
						endif
				case 20	if System_Rly20Bool.IsBool()==0 then 
							PulseTime=System_Rly20Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly20Thread
							else if Rly20 then Rly20=off else Rly20=on endif endif
						endif
				case 21	if System_Rly21Bool.IsBool()==0 then 
							PulseTime=System_Rly21Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly21Thread
							else if Rly21 then Rly21=off else Rly21=on endif endif
						endif
				case 22	if System_Rly22Bool.IsBool()==0 then 
							PulseTime=System_Rly22Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly22Thread
							else if Rly22 then Rly22=off else Rly22=on endif endif
						endif
				case 23	if System_Rly23Bool.IsBool()==0 then 
							PulseTime=System_Rly23Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly23Thread
							else if Rly23 then Rly23=off else Rly23=on endif endif
						endif
				case 24	if System_Rly24Bool.IsBool()==0 then 
							PulseTime=System_Rly24Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly24Thread
							else if Rly24 then Rly24=off else Rly24=on endif endif
						endif
				case 25	if System_Rly25Bool.IsBool()==0 then 
							PulseTime=System_Rly25Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly25Thread
							else if Rly25 then Rly25=off else Rly25=on endif endif
						endif
				case 26	if System_Rly26Bool.IsBool()==0 then 
							PulseTime=System_Rly26Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly26Thread
							else if Rly26 then Rly26=off else Rly26=on endif endif
						endif
				case 27	if System_Rly27Bool.IsBool()==0 then 
							PulseTime=System_Rly27Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly27Thread
							else if Rly27 then Rly27=off else Rly27=on endif endif
						endif
				case 28	if System_Rly28Bool.IsBool()==0 then 
							PulseTime=System_Rly28Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly28Thread
							else if Rly28 then Rly28=off else Rly28=on endif endif
						endif
				case 29	if System_Rly29Bool.IsBool()==0 then 
							PulseTime=System_Rly29Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly29Thread
							else if Rly29 then Rly29=off else Rly29=on endif endif
						endif
				case 30	if System_Rly30Bool.IsBool()==0 then 
							PulseTime=System_Rly30Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly30Thread
							else if Rly30 then Rly30=off else Rly30=on endif endif
						endif
				case 31	if System_Rly31Bool.IsBool()==0 then 
							PulseTime=System_Rly31Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly31Thread
							else if Rly31 then Rly31=off else Rly31=on endif endif
						endif
				case 32	if System_Rly32Bool.IsBool()==0 then 
							PulseTime=System_Rly32Bool.GetNumAscii(Zero)
							if PulseTime>MinRelayPulse then threadstart Rly32Thread
							else if Rly32 then Rly32=off else Rly32=on endif endif
						endif
			endselect
			SystemRlysUpdated = 0		; ready for next trigger
		endif
		
		if System_IO1AttachedRly then 
			AttachedRly = System_IO1AttachedRly
			GetAttachedRly()
			IO1 = AttachedRlyState 
		endif
		if System_IO2AttachedRly then 
			AttachedRly = System_IO2AttachedRly
			GetAttachedRly()
			IO2 = AttachedRlyState 
		endif
		if System_IO3AttachedRly then 
			AttachedRly = System_IO3AttachedRly
			GetAttachedRly()
			IO3 = AttachedRlyState 
		endif
		if System_IO4AttachedRly then 
			AttachedRly = System_IO4AttachedRly
			GetAttachedRly()
			IO4 = AttachedRlyState 
		endif
		if System_IO5AttachedRly then 
			AttachedRly = System_IO5AttachedRly
			GetAttachedRly()
			IO5 = AttachedRlyState 
		endif
		if System_IO6AttachedRly then 
			AttachedRly = System_IO6AttachedRly
			GetAttachedRly()
			IO6 = AttachedRlyState 
		endif
		if System_IO7AttachedRly then 
			AttachedRly = System_IO7AttachedRly
			GetAttachedRly()
			IO7 = AttachedRlyState 
		endif
		if System_IO8AttachedRly then 
			AttachedRly = System_IO8AttachedRly
			GetAttachedRly()
			IO8 = AttachedRlyState 
		endif
	
		SchT = (Hours*3600) + (Minutes*60) + Seconds	; calc time as seconds from midnight
		
		for SchX = 1 to 8
			schState = 0
			select UTC.Wday
				case 0 if SchWDay[SchX]&0x40 schState = 1	; check if today is active
				case 1 if SchWDay[SchX]&0x20 schState = 1
				case 2 if SchWDay[SchX]&0x10 schState = 1
				case 3 if SchWDay[SchX]&0x08 schState = 1
				case 4 if SchWDay[SchX]&0x04 schState = 1
				case 5 if SchWDay[SchX]&0x02 schState = 1
				case 6 if SchWDay[SchX]&0x01 schState = 1
			endselect			
			if schState then
				schState = 0
				if SchT>SchStartA[SchX] and SchT<SchStopA[SchX] then schState = 1 endif	 
				if SchT>SchStartB[SchX] and SchT<SchStopB[SchX] then schState = 1 endif
				system.Schedules[SchX] = schState
				SchStatus[SchX] <<= 1
				if schState SchStatus[SchX] |= 1
				schState = SchRelays[SchX]
				if SchStatus[SchX]&3==0x01 then
					system.Relays[schState] = on		; } action 01 and 10, they are the change (edge)
				endif
				if SchStatus[SchX]&3==0x02 then
					system.Relays[schState] = off	; } ignore 00 and 11, they are the steady state
				endif
			endif
		next
		
		CTreset[1] <<= 1
		if System_CtrReset1.BooleanEval() CTreset[1] |= 1
		if CTreset[1]&3 == 0x01 then 
			if System_CtrCap1.Length==0 System_CtrCapt1 = System_CtrVal1 ; no capture defined so do it on reset
			System_CtrVal1 = 0							; reset the counter/timer
		endif
		CTcount[1] <<= 1
		if System_CtrCount1.BooleanEval() CTcount[1] |= 1
		if CTcount[1]&3 == 0x01 System_CtrVal1 += 1		; increment counter/timer
		CTcapt[1] <<= 1
		if System_CtrCap1.BooleanEval() CTcapt[1] |= 1
		if CTcapt[1]&3 == 0x01 System_CtrCapt1 = System_CtrVal1 
		
		CTreset[2] <<= 1
		if System_CtrReset2.BooleanEval() CTreset[2] |= 1
		if CTreset[2]&3 == 0x01 then 
			if System_CtrCap2.Length==0 System_CtrCapt2 = System_CtrVal2 
			System_CtrVal2 = 0	
		endif
		CTcount[2] <<= 1
		if System_CtrCount2.BooleanEval() CTcount[2] |= 1
		if CTcount[2]&3 == 0x01 System_CtrVal2 += 1		
		CTcapt[2] <<= 1
		if System_CtrCap2.BooleanEval() CTcapt[2] |= 1
		if CTcapt[2]&3 == 0x01 System_CtrCapt2 = System_CtrVal2 
		
		CTreset[3] <<= 1
		if System_CtrReset3.BooleanEval() CTreset[3] |= 1
		if CTreset[3]&3 == 0x01 then 
			if System_CtrCap3.Length==0 System_CtrCapt3 = System_CtrVal3 
			System_CtrVal3 = 0	
		endif
		CTcount[3] <<= 1
		if System_CtrCount3.BooleanEval() CTcount[3] |= 1
		if CTcount[3]&3 == 0x01 System_CtrVal3 += 1		
		CTcapt[3] <<= 1
		if System_CtrCap3.BooleanEval() CTcapt[3] |= 1
		if CTcapt[3]&3 == 0x01 System_CtrCapt3 = System_CtrVal3 
		
		CTreset[4] <<= 1
		if System_CtrReset4.BooleanEval() CTreset[4] |= 1
		if CTreset[4]&3 == 0x01 then 
			if System_CtrCap4.Length==0 System_CtrCapt4 = System_CtrVal4 
			System_CtrVal4 = 0	
		endif
		CTcount[4] <<= 1
		if System_CtrCount4.BooleanEval() CTcount[4] |= 1
		if CTcount[4]&3 == 0x01 System_CtrVal4 += 1		
		CTcapt[4] <<= 1
		if System_CtrCap4.BooleanEval() CTcapt[4] |= 1
		if CTcapt[4]&3 == 0x01 System_CtrCapt4 = System_CtrVal4 

		CTreset[5] <<= 1
		if System_CtrReset5.BooleanEval() CTreset[5] |= 1
		if CTreset[5]&3 == 0x01 then 
			if System_CtrCap5.Length==0 System_CtrCapt5 = System_CtrVal5 
			System_CtrVal5 = 0	
		endif
		CTcount[5] <<= 1
		if System_CtrCount5.BooleanEval() CTcount[5] |= 1
		if CTcount[5]&3 == 0x01 System_CtrVal5 += 1		
		CTcapt[5] <<= 1
		if System_CtrCap5.BooleanEval() CTcapt[5] |= 1
		if CTcapt[5]&3 == 0x01 System_CtrCapt5 = System_CtrVal5 

		CTreset[6] <<= 1
		if System_CtrReset6.BooleanEval() CTreset[6] |= 1
		if CTreset[6]&3 == 0x01 then 
			if System_CtrCap6.Length==0 System_CtrCapt6 = System_CtrVal6 
			System_CtrVal6 = 0	
		endif
		CTcount[6] <<= 1
		if System_CtrCount6.BooleanEval() CTcount[6] |= 1
		if CTcount[6]&3 == 0x01 System_CtrVal6 += 1	
		CTcapt[6] <<= 1
		if System_CtrCap6.BooleanEval() CTcapt[6] |= 1
		if CTcapt[6]&3 == 0x01 System_CtrCapt6 = System_CtrVal6 
		
		CTreset[7] <<= 1
		if System_CtrReset7.BooleanEval() CTreset[7] |= 1
		if CTreset[7]&3 == 0x01 then 
			if System_CtrCap7.Length==0 System_CtrCapt7 = System_CtrVal7 
			System_CtrVal7 = 0	
		endif
		CTcount[7] <<= 1
		if System_CtrCount7.BooleanEval() CTcount[7] |= 1
		if CTcount[7]&3 == 0x01 System_CtrVal7 += 1	
		CTcapt[7] <<= 1
		if System_CtrCap7.BooleanEval() CTcapt[7] |= 1
		if CTcapt[7]&3 == 0x01 System_CtrCapt7 = System_CtrVal7 
			
		CTreset[8] <<= 1
		if System_CtrReset8.BooleanEval() CTreset[8] |= 1
		if CTreset[8]&3 == 0x01 then 
			if System_CtrCap8.Length==0 System_CtrCapt8 = System_CtrVal8 
			System_CtrVal8 = 0	
		endif
		CTcount[8] <<= 1
		if System_CtrCount8.BooleanEval() CTcount[8] |= 1
		if CTcount[8]&3 == 0x01 System_CtrVal8 += 1		
		CTcapt[8] <<= 1
		if System_CtrCap8.BooleanEval() CTcapt[8] |= 1
		if CTcapt[8]&3 == 0x01 System_CtrCapt8 = System_CtrVal8 
	loop
endthread

function GetAttachedRly()
	select AttachedRly
		case 1 AttachedRlyState = Rly1
		case 2 AttachedRlyState = Rly2
		case 3 AttachedRlyState = Rly3
		case 4 AttachedRlyState = Rly4
		case 5 AttachedRlyState = Rly5
		case 6 AttachedRlyState = Rly6
		case 7 AttachedRlyState = Rly7
		case 8 AttachedRlyState = Rly8
		case 9 AttachedRlyState = Rly9
		case 10 AttachedRlyState = Rly10
		case 11 AttachedRlyState = Rly11
		case 12 AttachedRlyState = Rly12
		case 13 AttachedRlyState = Rly13
		case 14 AttachedRlyState = Rly14
		case 15 AttachedRlyState = Rly15
		case 16 AttachedRlyState = Rly16
		case 17 AttachedRlyState = Rly17
		case 18 AttachedRlyState = Rly18
		case 19 AttachedRlyState = Rly19
		case 20 AttachedRlyState = Rly20
		case 21 AttachedRlyState = Rly21
		case 22 AttachedRlyState = Rly22
		case 23 AttachedRlyState = Rly23
		case 24 AttachedRlyState = Rly24
		case 25 AttachedRlyState = Rly25
		case 26 AttachedRlyState = Rly26
		case 27 AttachedRlyState = Rly27
		case 28 AttachedRlyState = Rly28
		case 29 AttachedRlyState = Rly29
		case 30 AttachedRlyState = Rly30
		case 31 AttachedRlyState = Rly31
		case 32 AttachedRlyState = Rly32
	endselect
	return
endfunction
		
thread UpdateCheckedStrings(SystemCmdUpdated)
	if System_Cmd==1 then ModBusChecked="checked" else ModBusChecked=" " endif
	if System_Cmd==2 then AsciiChecked="checked" else AsciiChecked=" " endif
	if System_Cmd==3 then BinaryChecked="checked" else BinaryChecked=" " endif
	if System_Cmd==4 then AESChecked="checked" else AESChecked=" " endif
    if System_Cmd==5 then PhoneChecked="checked" else PhoneChecked=" " endif
	if System_EnablePW==1 then PWChecked="checked" else PWChecked=" " endif
	if System_EnableDHCP==1 then DHCPChecked="checked" else DHCPChecked=" " endif
	SystemCmdUpdated = 0;
endthread

function generateEmailMsg()
	msg = "System Status:" ~ CR
	msg = msg ~ System_Rly1Name
	if Rly1 msg = msg ~ " - Active"
	msg = msg ~ CR
	msg = msg ~ System_Rly2Name
	if Rly2 msg = msg ~ " - Active"
	msg = msg ~ CR
	msg = msg ~ System_Rly3Name
	if Rly3 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly4Name
	if Rly4 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly5Name
	if Rly5 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly6Name
	if Rly6 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly7Name
	if Rly7 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly8Name
	if Rly8 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly9Name
	if Rly9 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly10Name
	if Rly10 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly11Name
	if Rly11 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly12Name
	if Rly12 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly13Name
	if Rly13 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly14Name
	if Rly14 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly15Name
	if Rly15 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly16Name
	if Rly16 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly17Name
	if Rly17 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly18Name
	if Rly18 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly19Name
	if Rly19 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly20Name
	if Rly20 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly21Name
	if Rly21 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly22Name
	if Rly22 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly23Name
	if Rly23 msg = msg ~ " - Active" 
	msg = msg ~ CR
	msg = msg ~ System_Rly24Name
	if Rly24 msg = msg ~ " - Active" 
	msg = msg ~ CR ~ CR
	msg = msg ~ System_Rly25Name
	if Rly25 msg = msg ~ " - Active"
	msg = msg ~ CR
	msg = msg ~ System_Rly26Name
	if Rly26 msg = msg ~ " - Active"
	msg = msg ~ CR
	msg = msg ~ System_Rly27Name
	if Rly27 msg = msg ~ " - Active"
	msg = msg ~ CR
	msg = msg ~ System_Rly28Name
	if Rly28 msg = msg ~ " - Active"
	msg = msg ~ CR
	msg = msg ~ System_Rly29Name
	if Rly29 msg = msg ~ " - Active"
	msg = msg ~ CR
	msg = msg ~ System_Rly30Name
	if Rly30 msg = msg ~ " - Active"
	msg = msg ~ CR
	msg = msg ~ System_Rly31Name
	if Rly31 msg = msg ~ " - Active"
	msg = msg ~ CR
	msg = msg ~ System_Rly32Name
	if Rly32 msg = msg ~ " - Active"
	msg = msg ~ CR

	msg = msg ~ System_IO1Name ~ " - "
	if IO1_s&4 then msg = msg ~ "Analogue - " ~ IO1 
	else 
		select IO1_s&0x30
			case 0x30 msg = msg ~ "Digital - Output active"
			case 0x10 msg = msg ~ "Digital - Input active"
			else msg = msg ~ "Digital"
		endselect
	endif
	msg = msg ~ CR
	msg = msg ~ System_IO2Name ~ " - "
	if IO2_s&4 then msg = msg ~ "Analogue - " ~ IO2 
	else 
		select IO2_s&0x30
			case 0x30 msg = msg ~ "Digital - Output active"
			case 0x10 msg = msg ~ "Digital - Input active"
			else msg = msg ~ "Digital"
		endselect
	endif
	msg = msg ~ CR
	msg = msg ~ System_IO3Name ~ " - "
	if IO3_s&4 then msg = msg ~ "Analogue - " ~ IO3 
	else 
		select IO3_s&0x30
			case 0x30 msg = msg ~ "Digital - Output active"
			case 0x10 msg = msg ~ "Digital - Input active"
			else msg = msg ~ "Digital"
		endselect
	endif
	msg = msg ~ CR
	msg = msg ~ System_IO4Name ~ " - "
	if IO4_s&4 then msg = msg ~ "Analogue - " ~ IO4 
	else 
		select IO4_s&0x30
			case 0x30 msg = msg ~ "Digital - Output active"
			case 0x10 msg = msg ~ "Digital - Input active"
			else msg = msg ~ "Digital"
		endselect
	endif
	msg = msg ~ CR
	msg = msg ~ System_IO5Name ~ " - "
	if IO5_s&4 then msg = msg ~ "Analogue - " ~ IO5 
	else 
		select IO5_s&0x30
			case 0x30 msg = msg ~ "Digital - Output active"
			case 0x10 msg = msg ~ "Digital - Input active"
			else msg = msg ~ "Digital"
		endselect
	endif
	msg = msg ~ CR
	msg = msg ~ System_IO6Name ~ " - "
	if IO6_s&4 then msg = msg ~ "Analogue - " ~ IO6 
	else 
		select IO6_s&0x30
			case 0x30 msg = msg ~ "Digital - Output active"
			case 0x10 msg = msg ~ "Digital - Input active"
			else msg = msg ~ "Digital"
		endselect
	endif
	msg = msg ~ CR
	msg = msg ~ System_IO7Name ~ " - "
	if IO7_s&4 then msg = msg ~ "Analogue - " ~ IO7 
	else 
		select IO7_s&0x30
			case 0x30 msg = msg ~ "Digital - Output active"
			case 0x10 msg = msg ~ "Digital - Input active"
			else msg = msg ~ "Digital"
		endselect
	endif
	msg = msg ~ CR
	msg = msg ~ System_IO8Name ~ " - "
	if IO8_s&4 then msg = msg ~ "Analogue - " ~ IO8 
	else 
		select IO8_s&0x30
			case 0x30 msg = msg ~ "Digital - Output active"
			case 0x10 msg = msg ~ "Digital - Input active"
			else msg = msg ~ "Digital"
		endselect
	endif
	msg = msg ~ CR

	if System_CtrName1.Length>0 msg = msg ~ System_CtrName1 ~ " - " ~ System_CtrVal1 ~ " - " ~ System_CtrCapt1 ~ CR
	if System_CtrName2.Length>0 msg = msg ~ System_CtrName2 ~ " - " ~ System_CtrVal2 ~ " - " ~ System_CtrCapt2 ~ CR
	if System_CtrName3.Length>0 msg = msg ~ System_CtrName3 ~ " - " ~ System_CtrVal3 ~ " - " ~ System_CtrCapt3 ~ CR
	if System_CtrName4.Length>0 msg = msg ~ System_CtrName4 ~ " - " ~ System_CtrVal4 ~ " - " ~ System_CtrCapt4 ~ CR
	if System_CtrName5.Length>0 msg = msg ~ System_CtrName5 ~ " - " ~ System_CtrVal5 ~ " - " ~ System_CtrCapt5 ~ CR
	if System_CtrName6.Length>0 msg = msg ~ System_CtrName6 ~ " - " ~ System_CtrVal6 ~ " - " ~ System_CtrCapt6 ~ CR
	if System_CtrName7.Length>0 msg = msg ~ System_CtrName7 ~ " - " ~ System_CtrVal7 ~ " - " ~ System_CtrCapt7 ~ CR
	if System_CtrName8.Length>0 msg = msg ~ System_CtrName8 ~ " - " ~ System_CtrVal8 ~ " - " ~ System_CtrCapt8 ~ CR

    msg = msg ~ System_PingHost1 ~ " - " ~ PingTime1 ~ CR
    msg = msg ~ System_PingHost2 ~ " - " ~ PingTime2 ~ CR
    
	msg = msg ~ "..End.." ~ CR
	LedBlue = on
	return
endfunction	
		
thread SendEmails(const)
	do
		if eIdx>7 then eIdx=0 endif											; keep range in 0-7
		select eIdx
			case 0
				if armed[eIdx] then
					if System_EmailTrigger1.BooleanEval() then
						generateEmailMsg()
						em1.Send(System_EmailSubject1, msg, eResponse)		; send the email
						armed[eIdx] = 0										; dis-arm so we don't keep sending it
					endif
				else
					if System_EmailTrigger1.BooleanEval()==0 then
						armed[eIdx] = 1										; re-arm the email
					endif
				endif
			case 1
				if armed[eIdx] then
					if System_EmailTrigger2.BooleanEval() then
						generateEmailMsg()
						em2.Send(System_EmailSubject2, msg, eResponse)		; send the email
						armed[eIdx] = 0										; dis-arm so we don't keep sending it
					endif
				else
					if System_EmailTrigger2.BooleanEval()==0 then
						armed[eIdx] = 1										; re-arm the email
					endif
				endif
			case 2
				if armed[eIdx] then
					if System_EmailTrigger3.BooleanEval() then
						generateEmailMsg()
						em3.Send(System_EmailSubject3, msg, eResponse)		; send the email
						armed[eIdx] = 0										; dis-arm so we don't keep sending it
					endif
				else
					if System_EmailTrigger3.BooleanEval()==0 then
						armed[eIdx] = 1										; re-arm the email
					endif
				endif
			case 3
				if armed[eIdx] then
					if System_EmailTrigger4.BooleanEval() then
						generateEmailMsg()
						em4.Send(System_EmailSubject4, msg, eResponse)		; send the email
						armed[eIdx] = 0										; dis-arm so we don't keep sending it
					endif
				else
					if System_EmailTrigger4.BooleanEval()==0 then
						armed[eIdx] = 1										; re-arm the email
					endif
				endif
			case 4
				if armed[eIdx] then
					if System_EmailTrigger5.BooleanEval() then
						generateEmailMsg()
						em5.Send(System_EmailSubject5, msg, eResponse)		; send the email
						armed[eIdx] = 0										; dis-arm so we don't keep sending it
					endif
				else
					if System_EmailTrigger5.BooleanEval()==0 then
						armed[eIdx] = 1										; re-arm the email
					endif
				endif
			case 5
				if armed[eIdx] then
					if System_EmailTrigger6.BooleanEval() then
						generateEmailMsg()
						em6.Send(System_EmailSubject6, msg, eResponse)		; send the email
						armed[eIdx] = 0										; dis-arm so we don't keep sending it
					endif
				else
					if System_EmailTrigger6.BooleanEval()==0 then
						armed[eIdx] = 1										; re-arm the email
					endif
				endif
			case 6
				if armed[eIdx] then
					if System_EmailTrigger7.BooleanEval() then
						generateEmailMsg()
						em7.Send(System_EmailSubject7, msg, eResponse)		; send the email
						armed[eIdx] = 0										; dis-arm so we don't keep sending it
					endif
				else
					if System_EmailTrigger7.BooleanEval()==0 then
						armed[eIdx] = 1										; re-arm the email
					endif
				endif
			case 7
				if armed[eIdx] then
					if System_EmailTrigger8.BooleanEval() then
						generateEmailMsg()
						em8.Send(System_EmailSubject8, msg, eResponse)		; send the email
						armed[eIdx] = 0										; dis-arm so we don't keep sending it
					endif
				else
					if System_EmailTrigger8.BooleanEval()==0 then
						armed[eIdx] = 1										; re-arm the email
					endif
				endif
		endselect
		eIdx += 1	
		if LedBlue then
			if eResponse==0 then
				LedGreen = on	
				LedBlue = off
			else
				LedRed = on
				LedBlue = off
			endif
		endif
		threadsleep 10
	loop
endthread
				
thread main(const)
	if initControl != AppVersion Init()		; init module if different from app version
;	Init()									; uncomment this line to force init
	
	if System_RLY_PUR&0x00000001 Rly1 = RelayStore[0]		; restore relay states on power up
	if System_RLY_PUR&0x00000002 Rly2 = RelayStore[1]
	if System_RLY_PUR&0x00000004 Rly3 = RelayStore[2]
	if System_RLY_PUR&0x00000008 Rly4 = RelayStore[3]
	if System_RLY_PUR&0x00000010 Rly5 = RelayStore[4] 
	if System_RLY_PUR&0x00000020 Rly6 = RelayStore[5]
	if System_RLY_PUR&0x00000040 Rly7 = RelayStore[6] 
	if System_RLY_PUR&0x00000080 Rly8 = RelayStore[7]
	if System_RLY_PUR&0x00000100 Rly9 = RelayStore[8]
	if System_RLY_PUR&0x00000200 Rly10 = RelayStore[9]
	if System_RLY_PUR&0x00000400 Rly11 = RelayStore[10] 
	if System_RLY_PUR&0x00000800 Rly12 = RelayStore[11] 
	if System_RLY_PUR&0x00001000 Rly13 = RelayStore[12] 
	if System_RLY_PUR&0x00002000 Rly14 = RelayStore[13] 
	if System_RLY_PUR&0x00004000 Rly15 = RelayStore[14]
	if System_RLY_PUR&0x00008000 Rly16 = RelayStore[15]
	if System_RLY_PUR&0x00010000 Rly17 = RelayStore[16] 
	if System_RLY_PUR&0x00020000 Rly18 = RelayStore[17] 
	if System_RLY_PUR&0x00040000 Rly19 = RelayStore[18] 
	if System_RLY_PUR&0x00080000 Rly20 = RelayStore[19] 
	if System_RLY_PUR&0x00100000 Rly21 = RelayStore[20] 
	if System_RLY_PUR&0x00200000 Rly22 = RelayStore[21]
	if System_RLY_PUR&0x00400000 Rly23 = RelayStore[22] 
	if System_RLY_PUR&0x00800000 Rly24 = RelayStore[23] 
	if System_RLY_PUR&0x01000000 Rly25 = RelayStore[24] 
	if System_RLY_PUR&0x02000000 Rly26 = RelayStore[25]
	if System_RLY_PUR&0x04000000 Rly27 = RelayStore[26] 
	if System_RLY_PUR&0x08000000 Rly28 = RelayStore[27] 
	if System_RLY_PUR&0x10000000 Rly29 = RelayStore[28] 
	if System_RLY_PUR&0x20000000 Rly30 = RelayStore[29]
	if System_RLY_PUR&0x40000000 Rly31 = RelayStore[30] 
	if System_RLY_PUR&0x80000000 Rly32 = RelayStore[31] 	
	
	CLS = {c}12 ~ {C}19 ~ {c}4 					; setup LCD control strings
	CR = {c}13 ~ {C}10

	AppVerMajor = AppMajor						; set variables for status page display
	AppVerMinor = AppMinor
	
	select System_ModbusBaud
		case 1 ModbusRTU.BaudRate = baud9600 
		case 2 ModbusRTU.BaudRate = baud19200 
		case 3 ModbusRTU.BaudRate = baud31250 
		case 4 ModbusRTU.BaudRate = baud38400 
		case 5 ModbusRTU.BaudRate = baud57600 
		case 6 ModbusRTU.BaudRate = baud115200 
		case 7 ModbusRTU.BaudRate = baud250k 
		case 8 ModbusRTU.BaudRate = baud500k 
		case 9 ModbusRTU.BaudRate = baud1M 
	endselect

	ModbusRTU.Parity = System_ModbusParity
	if System_ModbusParity==0 then ModbusRTU.StopBits = 2 ; 2 stop bits when no parity used, 1 stop bit with parity
	else ModbusRTU.StopBits = 1 
	endif	
		
	for x = 1 to 3							; flash blue led to indicate this firmware is loaded
		threadsleep	500
		LedBlue = on
		threadsleep	500
		LedBlue = off
	next
	
	for eIdx=0 to 7 armed[eIdx] = 1 next	; arm all emails
	
	SystemCmdUpdated = 1;
    do loop while system.Booting

    tcpip.ReadMacAddr(msg)                  ; read and format MAC address for display on Network page (_config2.htm)
    System_MAC = {h02} msg[0] ~ ":" ~ {h02} msg[1] ~ ":" ~ {h02} msg[2] ~ ":" ~ {h02} msg[3] ~ ":" ~ {h02} msg[4] ~ ":" ~ {h02} msg[5]
    
    Zero = 0
    threadsleep 1000
    
    if System_PingRepeat1>0 then    
        DNSResolve(System_PingHost1, PingIP1) 
    endif
    if System_PingRepeat2>0 then    
        DNSResolve(System_PingHost2, PingIP2) 
    endif
    if System_PingRepeat3>0 then    
        DNSResolve(System_PingHost3, PingIP3) 
    endif
    if System_PingRepeat4>0 then    
        DNSResolve(System_PingHost4, PingIP4) 
    endif

    threadstart SequencerUpdateOutputs
    threadstart SequencerUpdateCmds
    threadstart RunSequencer
	threadstart UpdateCheckedStrings
	threadstart CalcVoltsTemp
	threadstart TcpipCmd
	threadstart	SendEmails
	threadstart RunBooleanProcesses
	threadstart P2P
	threadstart WDayUpdate
	threadstart	P2PAES
	threadstart	DST
	threadstart RelayUpdate
	threadstart RLYPUR
    threadstart Reboot
    if System_PingRepeat1>0 threadstart Ping1
    if System_PingRepeat2>0 threadstart Ping2
    if System_PingRepeat3>0 threadstart Ping3
    if System_PingRepeat4>0 threadstart Ping4
 	
	select system.ModuleID
		case 30
			Module = "dS3484"			; Load the Module string with module name
		case 31
			Module = "dS1242"
		case 34
			Module = "dS2824"
		case 35
			Module = "dS378"
        case 42
            Module = "dS2832"
	endselect
		
	VerMajor = system.VerMajor			; move to a variable so it can be accesssed by webpage 
	VerMinor = system.VerMinor
	
	Nonce = system.Random				; start with a random value
	
	do 
		FlashWritePending = system.FlashPending	; keep up-to-date so webpage can access it
		Hours = UTC.Hour
		Minutes = UTC.Minute
		Seconds = UTC.Second
        seq1Timer = system.SleepTimer(seq1Handle)
        threadsleep 100
	loop
endthread		


thread Ping1(const)
int32 count

    PingTime1 = 1                                           ; 1uS - impossibly low ping time allows immediate start without waiting for first ping
    threadsleep System_PingDelay1*1000                      ; start-up delay
    count = System_PingAttempts1
    do
        PingTimer1 = 0                                  ; init ping timer to 0
        tcpip.Ping(PingIP1, PingTimer1)
        threadsleep System_PingRepeat1*1000             ; delay to next ping 
        if PingTimer1 then
            count = System_PingAttempts1                ; we received an echo so reset counter and update PingTime
            PingTime1 = PingTimer1
        else
            count -= 1                                  ; echo failed
            if count == 0 then
                PingTime1 = 0                           ; failed to detect remote system
                count = System_PingAttempts1            ; reset the attempts counter
                threadsleep System_PingDelay1*1000      ; delay before restarting pings 
            endif
        endif
    loop
endthread

thread Ping2(const)
int32 count

    PingTime2 = 1                                           ; 1uS - impossibly low ping time allows immediate start without waiting for first ping
    threadsleep System_PingDelay2*1000                      ; start-up delay
    count = System_PingAttempts2
    do
        PingTimer2 = 0                                  ; init ping timer to 0
        tcpip.Ping(PingIP2, PingTimer2)
        threadsleep System_PingRepeat2*1000             ; delay to next ping 
        if PingTimer2 then
            count = System_PingAttempts2                ; we received an echo so reset counter and update PingTime
            PingTime2 = PingTimer2
        else
            count -= 1                                  ; echo failed
            if count == 0 then
                PingTime2 = 0                           ; failed to detect remote system
                count = System_PingAttempts2            ; reset the attempts counter
                threadsleep System_PingDelay2*1000      ; delay before restarting pings 
            endif
        endif
    loop
endthread

thread Ping3(const)
int32 count

    PingTime3 = 1                                           ; 1uS - impossibly low ping time allows immediate start without waiting for first ping
    threadsleep System_PingDelay3*1000                      ; start-up delay
    count = System_PingAttempts3
    do
        PingTimer3 = 0                                  ; init ping timer to 0
        tcpip.Ping(PingIP3, PingTimer3)
        threadsleep System_PingRepeat3*1000             ; delay to next ping 
        if PingTimer3 then
            count = System_PingAttempts3                ; we received an echo so reset counter and update PingTime
            PingTime3 = PingTimer3
        else
            count -= 1                                  ; echo failed
            if count == 0 then
                PingTime3 = 0                           ; failed to detect remote system
                count = System_PingAttempts3            ; reset the attempts counter
                threadsleep System_PingDelay3*1000      ; delay before restarting pings 
            endif
        endif
    loop
endthread

thread Ping4(const)
int32 count

    PingTime4 = 1                                           ; 1uS - impossibly low ping time allows immediate start without waiting for first ping
    threadsleep System_PingDelay4*1000                      ; start-up delay
    count = System_PingAttempts4
    do
        PingTimer4 = 0                                  ; init ping timer to 0
        tcpip.Ping(PingIP4, PingTimer4)
        threadsleep System_PingRepeat4*1000             ; delay to next ping 
        if PingTimer4 then
            count = System_PingAttempts4                ; we received an echo so reset counter and update PingTime
            PingTime4 = PingTimer4
        else
            count -= 1                                  ; echo failed
            if count == 0 then
                PingTime4 = 0                           ; failed to detect remote system
                count = System_PingAttempts4            ; reset the attempts counter
                threadsleep System_PingDelay4*1000      ; delay before restarting pings 
            endif
        endif
    loop
endthread


function Init()
	System_HostName = "dS2832"
    System_IP = "192.168.0.123"
    System_SubNet = "255.255.255.0"
    System_Gateway = "192.168.0.1"
    System_DNS1 = "192.168.0.1"
    System_DNS2 = "8.8.8.8"
    System_TcpPort = 17123
    System_HttpPort = 80
    System_Cmd = 2              ; ASCII
    System_EnablePW = 0
    System_EnableDHCP = on
    System_Password = ""    
    System_AES_key = "This MUST be 32 characters long."
                     ;12345678901234567890123456789012
    System_PW = "123&Qx78"

    System_AD1Name = "AD1"
    System_AD2Name = "AD2"
    System_AD3Name = "AD3"
    System_AD4Name = "AD4"
    
    System_ModbusUID = 1
    System_ModbusBaud = 1               ; 9600
    System_ModbusParity = 1             ; even

    System_Rly1Name = "Relay 1"
    System_Rly2Name = "Relay 2"
    System_Rly3Name = "Relay 3"
    System_Rly4Name = "Relay 4"
    System_Rly5Name = "Relay 5"
    System_Rly6Name = "Relay 6"
    System_Rly7Name = "Relay 7"
    System_Rly8Name = "Relay 8"
    System_Rly9Name = "Relay 9"
    System_Rly10Name = "Relay 10"
    System_Rly11Name = "Relay 11"
    System_Rly12Name = "Relay 12"
    System_Rly13Name = "Relay 13"
    System_Rly14Name = "Relay 14"
    System_Rly15Name = "Relay 15"
    System_Rly16Name = "Relay 16"
    System_Rly17Name = "Relay 17"
    System_Rly18Name = "Relay 18"
    System_Rly19Name = "Relay 19"
    System_Rly20Name = "Relay 20"
    System_Rly21Name = "Relay 21"
    System_Rly22Name = "Relay 22"
    System_Rly23Name = "Relay 23"
    System_Rly24Name = "Relay 24"
    System_Rly25Name = "Relay 25"
    System_Rly26Name = "Relay 26"
    System_Rly27Name = "Relay 27"
    System_Rly28Name = "Relay 28"
    System_Rly29Name = "Relay 29"
    System_Rly30Name = "Relay 30"
    System_Rly31Name = "Relay 31"
    System_Rly32Name = "Relay 32"
    
    System_Rly1Set = ""
    System_Rly2Set = ""
    System_Rly3Set = ""
    System_Rly4Set = ""
    System_Rly5Set = ""
    System_Rly6Set = ""
    System_Rly7Set = ""
    System_Rly8Set = ""
    System_Rly9Set = ""
    System_Rly10Set = ""
    System_Rly11Set = ""
    System_Rly12Set = ""
    System_Rly13Set = ""
    System_Rly14Set = ""
    System_Rly15Set = ""
    System_Rly16Set = ""
    System_Rly17Set = ""
    System_Rly18Set = ""
    System_Rly19Set = ""
    System_Rly20Set = ""
    System_Rly21Set = ""
    System_Rly22Set = ""
    System_Rly23Set = ""
    System_Rly24Set = ""
    System_Rly25Set = ""
    System_Rly26Set = ""
    System_Rly27Set = ""
    System_Rly28Set = ""
    System_Rly29Set = ""
    System_Rly30Set = ""
    System_Rly31Set = ""
    System_Rly32Set = ""
    System_Rly1Rst = ""
    System_Rly2Rst = ""
    System_Rly3Rst = ""
    System_Rly4Rst = ""
    System_Rly5Rst = ""
    System_Rly6Rst = ""
    System_Rly7Rst = ""
    System_Rly8Rst = ""
    System_Rly9Rst = ""
    System_Rly10Rst = ""
    System_Rly11Rst = ""
    System_Rly12Rst = ""
    System_Rly13Rst = ""
    System_Rly14Rst = ""
    System_Rly15Rst = ""
    System_Rly16Rst = ""
    System_Rly17Rst = ""
    System_Rly18Rst = ""
    System_Rly19Rst = ""
    System_Rly20Rst = ""
    System_Rly21Rst = ""
    System_Rly22Rst = ""
    System_Rly23Rst = ""
    System_Rly24Rst = ""
    System_Rly25Rst = ""
    System_Rly26Rst = ""
    System_Rly27Rst = ""
    System_Rly28Rst = ""
    System_Rly29Rst = ""
    System_Rly30Rst = ""
    System_Rly31Rst = ""
    System_Rly32Rst = ""
    System_Rly1Tog = ""
    System_Rly2Tog = ""
    System_Rly3Tog = ""
    System_Rly4Tog = ""
    System_Rly5Tog = ""
    System_Rly6Tog = ""
    System_Rly7Tog = ""
    System_Rly8Tog = ""
    System_Rly9Tog = ""
    System_Rly10Tog = ""
    System_Rly11Tog = ""
    System_Rly12Tog = ""
    System_Rly13Tog = ""
    System_Rly14Tog = ""
    System_Rly15Tog = ""
    System_Rly16Tog = ""
    System_Rly17Tog = ""
    System_Rly18Tog = ""
    System_Rly19Tog = ""
    System_Rly20Tog = ""
    System_Rly21Tog = ""
    System_Rly22Tog = ""
    System_Rly23Tog = ""
    System_Rly24Tog = ""
    System_Rly25Tog = ""
    System_Rly26Tog = ""
    System_Rly27Tog = ""
    System_Rly28Tog = ""
    System_Rly29Tog = ""
    System_Rly30Tog = ""
    System_Rly31Tog = ""
    System_Rly32Tog = ""
    System_Rly1Bool = "0"
    System_Rly2Bool = System_Rly1Bool
    System_Rly3Bool = System_Rly1Bool
    System_Rly4Bool = System_Rly1Bool
    System_Rly5Bool = System_Rly1Bool
    System_Rly6Bool = System_Rly1Bool
    System_Rly7Bool = System_Rly1Bool
    System_Rly8Bool = System_Rly1Bool
    System_Rly9Bool = System_Rly1Bool
    System_Rly10Bool = System_Rly1Bool
    System_Rly11Bool = System_Rly1Bool
    System_Rly12Bool = System_Rly1Bool
    System_Rly13Bool = System_Rly1Bool
    System_Rly14Bool = System_Rly1Bool
    System_Rly15Bool = System_Rly1Bool
    System_Rly16Bool = System_Rly1Bool
    System_Rly17Bool = System_Rly1Bool
    System_Rly18Bool = System_Rly1Bool
    System_Rly19Bool = System_Rly1Bool
    System_Rly20Bool = System_Rly1Bool
    System_Rly21Bool = System_Rly1Bool
    System_Rly22Bool = System_Rly1Bool
    System_Rly23Bool = System_Rly1Bool
    System_Rly24Bool = System_Rly1Bool
    System_Rly25Bool = System_Rly1Bool
    System_Rly26Bool = System_Rly1Bool
    System_Rly27Bool = System_Rly1Bool
    System_Rly28Bool = System_Rly1Bool
    System_Rly29Bool = System_Rly1Bool
    System_Rly30Bool = System_Rly1Bool
    System_Rly31Bool = System_Rly1Bool
    System_Rly32Bool = System_Rly1Bool

    System_IO1Name = "IO1"
    System_IO2Name = "IO2"
    System_IO3Name = "IO3"
    System_IO4Name = "IO4"
    System_IO5Name = "IO5"
    System_IO6Name = "IO6"
    System_IO7Name = "IO7"
    System_IO8Name = "IO8"

    System_IO1Type = digitalpullup
    System_IO2Type = digitalpullup
    System_IO3Type = digitalpullup
    System_IO4Type = digitalpullup
    System_IO5Type = digitalpullup
    System_IO6Type = digitalpullup
    System_IO7Type = digitalpullup
    System_IO8Type = digitalpullup

    System_IO1AttachedRly = 0
    System_IO2AttachedRly = 0
    System_IO3AttachedRly = 0
    System_IO4AttachedRly = 0
    System_IO5AttachedRly = 0
    System_IO6AttachedRly = 0
    System_IO7AttachedRly = 0
    System_IO8AttachedRly = 0
    System_RLY_PUR = 0
    
    System_EmailFromAddr = "someone@aRealDomain.com"
    System_EmailAddr1 = "yourname@example.com"
    System_EmailAddr2 = "" 
    System_EmailAddr3 = "" 
    System_EmailAddr4 = "" 
    System_EmailAddr5 = "" 
    System_EmailAddr6 = "" 
    System_EmailAddr7 = "" 
    System_EmailAddr8 = "" 
    System_EmailSubject1 = "Event message goes here"    
    System_EmailSubject2 = "Leave Trigger empty to disable."
    System_EmailSubject3 = System_EmailSubject2
    System_EmailSubject4 = System_EmailSubject2
    System_EmailSubject5 = System_EmailSubject2
    System_EmailSubject6 = System_EmailSubject2
    System_EmailSubject7 = System_EmailSubject2
    System_EmailSubject8 = System_EmailSubject2
    
    System_EmailTrigger1 = "For example, D1"
    System_EmailTrigger2 = ""
    System_EmailTrigger3 = ""
    System_EmailTrigger4 = ""
    System_EmailTrigger5 = ""
    System_EmailTrigger6 = ""
    System_EmailTrigger7 = ""
    System_EmailTrigger8 = ""

    System_P2P_Input1 = "D1"
    System_P2P_Input2 = ""
    System_P2P_Input3 = ""
    System_P2P_Input4 = ""
    System_P2P_Input5 = ""
    System_P2P_Input6 = ""
    System_P2P_Input7 = ""
    System_P2P_Input8 = ""
    System_P2P_IP1 = "0.0.0.0"
    System_P2P_IP2 = System_P2P_IP1
    System_P2P_IP3 = System_P2P_IP1
    System_P2P_IP4 = System_P2P_IP1
    System_P2P_IP5 = System_P2P_IP1
    System_P2P_IP6 = System_P2P_IP1
    System_P2P_IP7 = System_P2P_IP1
    System_P2P_IP8 = System_P2P_IP1
    System_P2P_Port1 = 0
    System_P2P_Port2 = 0
    System_P2P_Port3 = 0
    System_P2P_Port4 = 0
    System_P2P_Port5 = 0
    System_P2P_Port6 = 0
    System_P2P_Port7 = 0
    System_P2P_Port8 = 0
    System_P2P_Relay1 = 1
    System_P2P_Relay2 = 1
    System_P2P_Relay3 = 1
    System_P2P_Relay4 = 1
    System_P2P_Relay5 = 1
    System_P2P_Relay6 = 1
    System_P2P_Relay7 = 1
    System_P2P_Relay8 = 1
    System_P2P_Action1 = 0
    System_P2P_Action2 = 0
    System_P2P_Action3 = 0
    System_P2P_Action4 = 0
    System_P2P_Action5 = 0
    System_P2P_Action6 = 0
    System_P2P_Action7 = 0
    System_P2P_Action8 = 0
    System_P2P_Timeout1 = 5000
    System_P2P_Timeout2 = System_P2P_Timeout1
    System_P2P_Timeout3 = System_P2P_Timeout1
    System_P2P_Timeout4 = System_P2P_Timeout1
    System_P2P_Timeout5 = System_P2P_Timeout1
    System_P2P_Timeout6 = System_P2P_Timeout1
    System_P2P_Timeout7 = System_P2P_Timeout1
    System_P2P_Timeout8 = System_P2P_Timeout1
    System_P2P_AES = 0

    System_Sch_R1 = 0
    System_Sch_WD1 = 0
    System_Sch_STH1a = 0
    System_Sch_STM1a = 0
    System_Sch_STS1a = 0
    System_Sch_SPH1a = 0    
    System_Sch_SPM1a = 0
    System_Sch_SPS1a = 0
    System_Sch_STH1b = 0    
    System_Sch_STM1b = 0
    System_Sch_STS1b = 0
    System_Sch_SPH1b = 0
    System_Sch_SPM1b = 0
    System_Sch_SPS1b = 0
    System_Sch_R2 = 0
    System_Sch_WD2 = 0
    System_Sch_STH2a = 0
    System_Sch_STM2a = 0
    System_Sch_STS2a = 0
    System_Sch_SPH2a = 0    
    System_Sch_SPM2a = 0
    System_Sch_SPS2a = 0
    System_Sch_STH2b = 0    
    System_Sch_STM2b = 0
    System_Sch_STS2b = 0
    System_Sch_SPH2b = 0
    System_Sch_SPM2b = 0
    System_Sch_SPS2b = 0
    System_Sch_R3 = 0
    System_Sch_WD3 = 0
    System_Sch_STH3a = 0
    System_Sch_STM3a = 0
    System_Sch_STS3a = 0
    System_Sch_SPH3a = 0    
    System_Sch_SPM3a = 0
    System_Sch_SPS3a = 0
    System_Sch_STH3b = 0    
    System_Sch_STM3b = 0
    System_Sch_STS3b = 0
    System_Sch_SPH3b = 0
    System_Sch_SPM3b = 0
    System_Sch_SPS3b = 0
    System_Sch_R4 = 0
    System_Sch_WD4 = 0
    System_Sch_STH4a = 0
    System_Sch_STM4a = 0
    System_Sch_STS4a = 0
    System_Sch_SPH4a = 0    
    System_Sch_SPM4a = 0
    System_Sch_SPS4a = 0
    System_Sch_STH4b = 0    
    System_Sch_STM4b = 0
    System_Sch_STS4b = 0
    System_Sch_SPH4b = 0
    System_Sch_SPM4b = 0
    System_Sch_SPS4b = 0
    System_Sch_R5 = 0
    System_Sch_WD5 = 0
    System_Sch_STH5a = 0
    System_Sch_STM5a = 0
    System_Sch_STS5a = 0
    System_Sch_SPH5a = 0    
    System_Sch_SPM5a = 0
    System_Sch_SPS5a = 0
    System_Sch_STH5b = 0    
    System_Sch_STM5b = 0
    System_Sch_STS5b = 0
    System_Sch_SPH5b = 0
    System_Sch_SPM5b = 0
    System_Sch_SPS5b = 0
    System_Sch_R6 = 0
    System_Sch_WD6 = 0
    System_Sch_STH6a = 0
    System_Sch_STM6a = 0
    System_Sch_STS6a = 0
    System_Sch_SPH6a = 0    
    System_Sch_SPM6a = 0
    System_Sch_SPS6a = 0
    System_Sch_STH6b = 0    
    System_Sch_STM6b = 0
    System_Sch_STS6b = 0
    System_Sch_SPH6b = 0
    System_Sch_SPM6b = 0
    System_Sch_SPS6b = 0
    System_Sch_R7 = 0
    System_Sch_WD7 = 0
    System_Sch_STH7a = 0
    System_Sch_STM7a = 0
    System_Sch_STS7a = 0
    System_Sch_SPH7a = 0    
    System_Sch_SPM7a = 0
    System_Sch_SPS7a = 0
    System_Sch_STH7b = 0    
    System_Sch_STM7b = 0
    System_Sch_STS7b = 0
    System_Sch_SPH7b = 0
    System_Sch_SPM7b = 0
    System_Sch_SPS7b = 0
    System_Sch_R8 = 0
    System_Sch_WD8 = 0
    System_Sch_STH8a = 0
    System_Sch_STM8a = 0
    System_Sch_STS8a = 0
    System_Sch_SPH8a = 0    
    System_Sch_SPM8a = 0
    System_Sch_SPS8a = 0
    System_Sch_STH8b = 0    
    System_Sch_STM8b = 0
    System_Sch_STS8b = 0
    System_Sch_SPH8b = 0
    System_Sch_SPM8b = 0
    System_Sch_SPS8b = 0
    
    System_CtrName1 = "Ctr1"
    System_CtrName2 = "Ctr2"
    System_CtrName3 = "Ctr3"
    System_CtrName4 = "Ctr4"
    System_CtrName5 = "Ctr5"
    System_CtrName6 = "Ctr6"
    System_CtrName7 = "Ctr7"
    System_CtrName8 = "Ctr8"
    System_CtrReset1 = ""
    System_CtrReset2 = ""
    System_CtrReset3 = ""
    System_CtrReset4 = ""
    System_CtrReset5 = ""
    System_CtrReset6 = ""
    System_CtrReset7 = ""
    System_CtrReset8 = ""
    System_CtrCount1 = ""
    System_CtrCount2 = ""
    System_CtrCount3 = ""
    System_CtrCount4 = ""
    System_CtrCount5 = ""
    System_CtrCount6 = ""
    System_CtrCount7 = ""
    System_CtrCount8 = ""
    System_CtrCap1 = ""
    System_CtrCap2 = ""
    System_CtrCap3 = ""
    System_CtrCap4 = ""
    System_CtrCap5 = ""
    System_CtrCap6 = ""
    System_CtrCap7 = ""
    System_CtrCap8 = ""
    
    System_PingHost1 = "example.com"
    System_PingHost2 = "192.168.1.2"
    System_PingHost3 = ""
    System_PingHost4 = ""
    System_PingRepeat1 = 0
    System_PingRepeat2 = 0
    System_PingRepeat3 = 0
    System_PingRepeat4 = 0
    System_PingAttempts1 = 3
    System_PingAttempts2 = 3
    System_PingAttempts3 = 3
    System_PingAttempts4 = 3
    System_PingDelay1 = 600
    System_PingDelay2 = 600
    System_PingDelay3 = 600
    System_PingDelay4 = 600

    for x = 0 to 127 
        sequencer[x] = 0 
     next

    TimeZone = "0"
    DaylightSaving = 1
            
    initControl = AppVersion
    return
endfunction

thread CalcVoltsTemp(1000)
	BrdTemp = ((TS1*3223)-500000)/1000	; thread runs once per second to keep
	Volts = PSU*18369/100000			; board temperature and volts updated
endthread
		
		
thread TcpipCmd(tcpip)
	tcpip.Read(tcpInBuf, tcpLength)		; read the tcp/ip data into the buffer
	select System_Cmd					; and branch to appropiate handler as
		case 1							; defined in System_Cmd.
			ModBus()
		case 2
			Ascii()
		case 3
			Binary()
		case 4
			AESBinary()				; AES also uses binary command set
        case 5
            PhoneApp()
	endselect
endthread
		
function Ascii()
	if tcpLength > 0 then
		cmdIdx = 0
		cmdStr = tcpInBuf.GetText(cmdIdx)							; extract command
		cmdStr = cmdStr.ToLower()
		tcpOutBuf = "Ok" ~ CR										; preload with ok, this will change if error		

		select cmdStr
			case "sr"												; Set Relay
				cmdIO = tcpInBuf.GetNumAscii(cmdIdx)				; extract Relay/IO port number
				cmdAction = tcpInBuf.GetText(cmdIdx)				; extract Action to take
				cmdPulseTime = tcpInBuf.GetNumAscii(cmdIdx)			; extract pulse time in 1mS units
				cmdAction = cmdAction.ToLower()
				RlyState = -1										; default to do nothing
				select cmdAction
					case "a"
						RlyState = on
					case "active"
						RlyState = on
					case "on"
						RlyState = on
					case "i"
						RlyState = off
					case "inactive"
						RlyState = off
					case "off"
						RlyState = off
					else 
						tcpOutBuf = "Unknown Action" ~ CR			; Don't know if relay supposed to be on or off!
				endselect
				if RlyState != -1 then
					PulseTime = cmdPulseTime						; in mS
					select cmdIO
						case 1 to 32
							SetRelay()							; set the relay	
						else
							tcpOutBuf = "Unknown relay number" ~ CR	; else don't know which IO to use!					
					endselect
				endif
			
			case "so"												; Set output
				cmdIO = tcpInBuf.GetNumAscii(cmdIdx)				; extract Relay/IO port number
				cmdAction = tcpInBuf.GetText(cmdIdx)				; extract Action to take
				cmdAction = cmdAction.ToLower()
				RlyState = -1										; default to do nothing
				select cmdAction
					case "a"
						RlyState = on
					case "active"
						RlyState = on
					case "on"
						RlyState = on
					case "i"
						RlyState = off
					case "inactive"
						RlyState = off
					case "off"
						RlyState = off
					else 
						tcpOutBuf = "Unknown Action" ~ CR			; Don't know if relay supposed to be on or off!
				endselect
				
				if RlyState != -1 then
					select cmdIO
						case 1 to 8
							SetIO()
						else
							tcpOutBuf = "Unknown IO number" ~ CR			; Don't know which IO to use!					
					endselect
				endif
				
			case "gr"
					cmdIO = tcpInBuf.GetNumAscii(cmdIdx)					; extract relay number
					select cmdIO
						case 1
							if Rly1 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 2
							if Rly2 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 3
							if Rly3 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 4
							if Rly4 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 5
							if Rly5 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 6
							if Rly6 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 7
							if Rly7 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 8
							if Rly8 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 9
							if Rly9 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 10
							if Rly10 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 11
							if Rly11 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 12
							if Rly12 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 13
							if Rly13 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 14
							if Rly14 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 15
							if Rly15 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 16
							if Rly16 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 17
							if Rly17 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 18
							if Rly18 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 19
							if Rly19 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 20
							if Rly20 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 21
							if Rly21 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 22
							if Rly22 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 23
							if Rly23 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 24
							if Rly24 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 25
							if Rly25 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 26
							if Rly26 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 27
							if Rly27 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 28
							if Rly28 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 29
							if Rly29 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 30
							if Rly30 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 31
							if Rly31 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						case 32
							if Rly32 == on then tcpOutBuf = "Active" ~ CR
							else tcpOutBuf = "InActive" ~ CR
							endif
						else
							tcpOutBuf = "Unknown relay number" ~ CR			; Don't know which relay to use!					
					endselect	
								
			case "gi"
					GetInput()
					
			case "ga"
					GetInput()

			case "gc"
				cmdIO = tcpInBuf.GetNumAscii(cmdIdx)					; extract counter number
				select cmdIO
					case 1 tcpOutBuf = System_CtrVal1 ~ ", " ~ System_CtrCapt1 ~ CR
					case 2 tcpOutBuf = System_CtrVal2 ~ ", " ~ System_CtrCapt2 ~ CR
					case 3 tcpOutBuf = System_CtrVal3 ~ ", " ~ System_CtrCapt3 ~ CR
					case 4 tcpOutBuf = System_CtrVal4 ~ ", " ~ System_CtrCapt4 ~ CR
					case 5 tcpOutBuf = System_CtrVal5 ~ ", " ~ System_CtrCapt5 ~ CR
					case 6 tcpOutBuf = System_CtrVal6 ~ ", " ~ System_CtrCapt6 ~ CR
					case 7 tcpOutBuf = System_CtrVal7 ~ ", " ~ System_CtrCapt7 ~ CR
					case 8 tcpOutBuf = System_CtrVal8 ~ ", " ~ System_CtrCapt8 ~ CR
					else
						tcpOutBuf = "Unknown counter number" ~ CR		; Don't know which counter to use!					
				endselect

			case "st"
					tcpOutBuf = "Module Type: " ~ Module ~ CR 
								~ "System Firmware Version: " ~ VerMajor ~ "." ~ VerMinor ~ CR 
								~ "Application Firmware Version: " ~ AppVerMajor ~ "." ~ AppVerMinor ~ CR 
								~ "Supply Voltage: " ~ Volts/10 ~ "." ~ Volts//10 ~ CR 
								~ "Board Temperature: " ~ BrdTemp/10 ~ "." ~ BrdTemp//10 ~ "C" ~ CR
			else
				tcpOutBuf = "Unknown Command" ~ CR
		endselect
		tcpip.Write(tcpOutBuf, tcpOutBuf.Length)
	endif
	return
endfunction

function SetRelay()					; assumes RlyState, cmdIO and pulseTime already set
	select cmdIO
		case 1
			if PulseTime>MinRelayPulse then threadstart Rly1Thread
			elseif RlyState==3 Rly1 = Rly1 ^ 1
			else Rly1 = RlyState endif
		case 2
			if PulseTime>MinRelayPulse then threadstart Rly2Thread
			elseif RlyState==3 Rly2 = Rly2 ^ 1
			else Rly2 = RlyState endif
		case 3
			if PulseTime>MinRelayPulse then threadstart Rly3Thread
			elseif RlyState==3 Rly3 = Rly3 ^ 1
			else Rly3 = RlyState endif
		case 4
			if PulseTime>MinRelayPulse then threadstart Rly4Thread
			elseif RlyState==3 Rly4 = Rly4 ^ 1
			else Rly4 = RlyState endif
		case 5
			if PulseTime>MinRelayPulse then threadstart Rly5Thread
			elseif RlyState==3 Rly5 = Rly5 ^ 1
			else Rly5 = RlyState endif
		case 6
			if PulseTime>MinRelayPulse then threadstart Rly6Thread
			elseif RlyState==3 Rly6 = Rly6 ^ 1
			else Rly6 = RlyState endif
		case 7
			if PulseTime>MinRelayPulse then threadstart Rly7Thread
			elseif RlyState==3 Rly7 = Rly7 ^ 1
			else Rly7 = RlyState endif
		case 8
			if PulseTime>MinRelayPulse then threadstart Rly8Thread
			elseif RlyState==3 Rly8 = Rly8 ^ 1
			else Rly8 = RlyState endif
		case 9
			if PulseTime>MinRelayPulse then threadstart Rly9Thread
			elseif RlyState==3 Rly9 = Rly9 ^ 1
			else Rly9 = RlyState endif
		case 10
			if PulseTime>MinRelayPulse then threadstart Rly10Thread
			elseif RlyState==3 Rly10 = Rly10 ^ 1
			else Rly10 = RlyState endif
		case 11
			if PulseTime>MinRelayPulse then threadstart Rly11Thread
			elseif RlyState==3 Rly11 = Rly11 ^ 1
			else Rly11 = RlyState endif
		case 12
			if PulseTime>MinRelayPulse then threadstart Rly12Thread
			elseif RlyState==3 Rly12 = Rly12 ^ 1
			else Rly12 = RlyState endif
		case 13
			if PulseTime>MinRelayPulse then threadstart Rly13Thread
			elseif RlyState==3 Rly13 = Rly13 ^ 1
			else Rly13 = RlyState endif
		case 14
			if PulseTime>MinRelayPulse then threadstart Rly14Thread
			elseif RlyState==3 Rly14 = Rly14 ^ 1
			else Rly14 = RlyState endif
		case 15
			if PulseTime>MinRelayPulse then threadstart Rly15Thread
			elseif RlyState==3 Rly15 = Rly15 ^ 1
			else Rly15 = RlyState endif
		case 16
			if PulseTime>MinRelayPulse then threadstart Rly16Thread
			elseif RlyState==3 Rly16 = Rly16 ^ 1
			else Rly16 = RlyState endif
		case 17
			if PulseTime>MinRelayPulse then threadstart Rly17Thread
			elseif RlyState==3 Rly17 = Rly17 ^ 1
			else Rly17 = RlyState endif
		case 18
			if PulseTime>MinRelayPulse then threadstart Rly18Thread
			elseif RlyState==3 Rly18 = Rly18 ^ 1
			else Rly18 = RlyState endif
		case 19
			if PulseTime>MinRelayPulse then threadstart Rly19Thread
			elseif RlyState==3 Rly19 = Rly19 ^ 1
			else Rly19 = RlyState endif
		case 20
			if PulseTime>MinRelayPulse then threadstart Rly20Thread
			elseif RlyState==3 Rly20 = Rly20 ^ 1
			else Rly20 = RlyState endif
		case 21
			if PulseTime>MinRelayPulse then threadstart Rly21Thread
			elseif RlyState==3 Rly21 = Rly21 ^ 1
			else Rly21 = RlyState endif
		case 22
			if PulseTime>MinRelayPulse then threadstart Rly22Thread
			elseif RlyState==3 Rly22 = Rly22 ^ 1
			else Rly22 = RlyState endif
		case 23
			if PulseTime>MinRelayPulse then threadstart Rly23Thread
			elseif RlyState==3 Rly23 = Rly23 ^ 1
			else Rly23 = RlyState endif
		case 24
			if PulseTime>MinRelayPulse then threadstart Rly24Thread
			elseif RlyState==3 Rly24 = Rly24 ^ 1
			else Rly24 = RlyState endif
		case 25
			if PulseTime>MinRelayPulse then threadstart Rly25Thread
			elseif RlyState==3 Rly25 = Rly25 ^ 1
			else Rly25 = RlyState endif
		case 26
			if PulseTime>MinRelayPulse then threadstart Rly26Thread
			elseif RlyState==3 Rly26 = Rly26 ^ 1
			else Rly26 = RlyState endif
		case 27
			if PulseTime>MinRelayPulse then threadstart Rly27Thread
			elseif RlyState==3 Rly27 = Rly27 ^ 1
			else Rly27 = RlyState endif
		case 28
			if PulseTime>MinRelayPulse then threadstart Rly28Thread
			elseif RlyState==3 Rly28 = Rly28 ^ 1
			else Rly28 = RlyState endif
		case 29
			if PulseTime>MinRelayPulse then threadstart Rly29Thread
			elseif RlyState==3 Rly29 = Rly29 ^ 1
			else Rly29 = RlyState endif
		case 30
			if PulseTime>MinRelayPulse then threadstart Rly30Thread
			elseif RlyState==3 Rly30 = Rly30 ^ 1
			else Rly30 = RlyState endif
		case 31
			if PulseTime>MinRelayPulse then threadstart Rly31Thread
			elseif RlyState==3 Rly31 = Rly31 ^ 1
			else Rly31 = RlyState endif
		case 32
			if PulseTime>MinRelayPulse then threadstart Rly32Thread
			elseif RlyState==3 Rly32 = Rly32 ^ 1
			else Rly32 = RlyState endif
	endselect
	return
endfunction

function SetIO()							; subroutine called from Ascii and Binary modes to set output
	select cmdIO
		case 1 
			IO1 = RlyState
		case 2
			IO2 = RlyState
		case 3
			IO3 = RlyState
		case 4
			IO4 = RlyState
		case 5
			IO5 = RlyState
		case 6
			IO6 = RlyState
		case 7
			IO7 = RlyState
		case 8
			IO8 = RlyState
	endselect
	return
endfunction

function GetInput()											; subroutine, as get digital and analogue are the same for dS378/dS2824/dS2832
	cmdIO = tcpInBuf.GetNumAscii(cmdIdx)					; extract IO port number
	select cmdIO
		case 1
			if IO1_s&0x04 then tcpOutBuf = IO1 ~ CR
			else
				if IO1 == off then tcpOutBuf = "InActive" ~ CR
				else tcpOutBuf = "Active" ~ CR
				endif
			endif
		case 2
			if IO2_s&0x04 then tcpOutBuf = IO2 ~ CR
			else
				if IO2 == off then tcpOutBuf = "InActive" ~ CR
				else tcpOutBuf = "Active" ~ CR
				endif
			endif
		case 3
			if IO3_s&0x04 then tcpOutBuf = IO3 ~ CR
			else
				if IO3 == off then tcpOutBuf = "InActive" ~ CR
				else tcpOutBuf = "Active" ~ CR
				endif
			endif
		case 4
			if IO4_s&0x04 then tcpOutBuf = IO4 ~ CR
			else
				if IO4 == off then tcpOutBuf = "InActive" ~ CR
				else tcpOutBuf = "Active" ~ CR
				endif
			endif
		case 5
			if IO5_s&0x04 then tcpOutBuf = IO5 ~ CR
			else
				if IO5 == off then tcpOutBuf = "InActive" ~ CR
				else tcpOutBuf = "Active" ~ CR
				endif
			endif
		case 6
			if IO6_s&0x04 then tcpOutBuf = IO6 ~ CR
			else
				if IO6 == off then tcpOutBuf = "InActive" ~ CR
				else tcpOutBuf = "Active" ~ CR
				endif
			endif
		case 7
			if IO7_s&0x04 then tcpOutBuf = IO7 ~ CR
			else
				if IO7 == off then tcpOutBuf = "InActive" ~ CR
				else tcpOutBuf = "Active" ~ CR
				endif
			endif
		case 8
			if IO8_s&0x04 then tcpOutBuf = IO8 ~ CR
			else
				if IO8 == off then tcpOutBuf = "InActive" ~ CR
				else tcpOutBuf = "Active" ~ CR
				endif
			endif
		else
			tcpOutBuf = "Unknown I/O number" ~ CR			; Don't know which relay to use!					
	endselect
	return
endfunction


function int32 GenNonce()
int32 x
int32 y
string s[10]
    for x=0 to 11 tcpOutBuf[x] = 0 next
    x = system.Random
    tcpOutBuf[12] = x >> 24
    tcpOutBuf[13] = x >> 16      
    tcpOutBuf[14] = x >> 8
    tcpOutBuf[15] = x
    s[0] = tcpOutBuf[12] ^ (System_PW[0] + System_PW[7])
    s[1] = tcpOutBuf[13] ^ (System_PW[1] + System_PW[6])
    s[2] = tcpOutBuf[14] ^ (System_PW[2] + System_PW[5])
    s[3] = tcpOutBuf[15] ^ (System_PW[3] + System_PW[4])
    x = 0;
    x = s.GetNumBinary(x, 4)
    y = x>>1
    y &= 0x7fffffff
    x=y^((0-(x&1))&0xd0000001)
    tcpLength = 16
    return x   
endfunction


function int32 checkNonce()
int32 x
    x = 12
    x = tcpInBuf.GetNumBinary(x, 4)
    if x==Nonce then x=1 else x=0 endif
    return x
endfunction


function PhoneApp()
int32 x
int32 junk

    if tcpLength == 16 then                         ; needs to be 16 bytes 
        tcpLength = 0
        for x = 0 to 11 tcpOutBuf[x] = 0 next    
        select tcpInBuf[0]
            case 0x41                               ; just ack command
                Nonce = GenNonce()  
            case 0x42  ; return module status
                x = checkNonce()
                if checkNonce() then
                    Nonce = GenNonce()  
                    loadStatus()
                endif     
            case 0x43                               ; Set Relay - relay num, state, pulse time/state (4 bytes), total 7 byte command
                if checkNonce() then
                   Nonce = GenNonce()  
                    cmdIO = tcpInBuf[1]             
                    RlyState = tcpInBuf[2]      
                    PulseTime = 3                    
                    PulseTime = tcpInBuf.GetNumBinary(PulseTime, 4)    
                    select cmdIO
                        case 1 to 32
                            SetRelay()    
                            tcpOutBuf[0] = 0       ; ACK
                        else
                            tcpOutBuf[0] = cmdIO   ; send relay number as NACK            
                    endselect
                endif
            case 0x44                               ; Set Output - output num, state, total 3 byte command
                if checkNonce() then
                    Nonce = GenNonce()  
                    cmdIO = tcpInBuf[1]   
                    if tcpInBuf[2]==0 then RlyState=off else RlyState=on endif  ; get state
                    select cmdIO
                        case 1 to 8
                            SetIO()                 ; set the output    
                            tcpOutBuf[0] = 0        ; ACK
                        else
                            tcpOutBuf[0] = cmdIO    ; NACK, unknown I/O number, send number as NACK                 
                    endselect
                endif                
            case 0x45                               ; Get Relay - 1st is requested relay, 2nd,4rd,4th are packed relays, 
                if checkNonce() then
                    Nonce = GenNonce()  
                    if Rly1==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x01 endif
                    if Rly2==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x02 endif
                    if Rly3==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x04 endif
                    if Rly4==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x08 endif
                    if Rly5==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x10 endif
                    if Rly6==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x20 endif
                    if Rly7==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x40 endif
                    if Rly8==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x80 endif
                    if Rly9==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x01 endif
                    if Rly10==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x02 endif
                    if Rly11==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x04 endif
                    if Rly12==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x08 endif
                    if Rly13==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x10 endif
                    if Rly14==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x20 endif
                    if Rly15==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x40 endif
                    if Rly16==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x80 endif                  
                    if Rly17==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x01 endif
                    if Rly18==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x02 endif
                    if Rly19==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x04 endif
                    if Rly20==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x08 endif
                    if Rly21==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x10 endif
                    if Rly22==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x20 endif
                    if Rly23==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x40 endif
                    if Rly24==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x80 endif          
                    if Rly25==on then tcpOutBuf[0] = tcpOutBuf[0] | 0x01 endif
                    if Rly26==on then tcpOutBuf[0] = tcpOutBuf[0] | 0x02 endif
                    if Rly27==on then tcpOutBuf[0] = tcpOutBuf[0] | 0x04 endif
                    if Rly28==on then tcpOutBuf[0] = tcpOutBuf[0] | 0x08 endif
                    if Rly29==on then tcpOutBuf[0] = tcpOutBuf[0] | 0x10 endif
                    if Rly30==on then tcpOutBuf[0] = tcpOutBuf[0] | 0x20 endif
                    if Rly31==on then tcpOutBuf[0] = tcpOutBuf[0] | 0x40 endif
                    if Rly32==on then tcpOutBuf[0] = tcpOutBuf[0] | 0x80 endif
                endif                
            case 0x46                               ; Get packed inputs
                if checkNonce() then
                    Nonce = GenNonce()  
                    if IO1==on then tcpOutBuf[0] = 0x01 endif
                    if IO2==on then tcpOutBuf[0] |= 0x02 endif
                    if IO3==on then tcpOutBuf[0] |= 0x04 endif
                    if IO4==on then tcpOutBuf[0] |= 0x08 endif
                    if IO5==on then tcpOutBuf[0] |= 0x10 endif
                    if IO6==on then tcpOutBuf[0] |= 0x20 endif
                    if IO7==on then tcpOutBuf[0] |= 0x40 endif
                    if IO8==on then tcpOutBuf[0] |= 0x80 endif
                endif                
            case 0x47                               ; Get Analog - 1st is high byte, 2nd is low byte of input
                if checkNonce() then
                    Nonce = GenNonce()  
                    if tcpInBuf[1]==0 then
                        mbX = IO1
                        tcpOutBuf[0] = mbX>>8           ; returns first 4 analog inputs 
                        tcpOutBuf[1] = mbX&255  
                        mbX = IO2
                        tcpOutBuf[2] = mbX>>8
                        tcpOutBuf[3] = mbX&255  
                        mbX = IO3
                        tcpOutBuf[4] = mbX>>8  
                        tcpOutBuf[5] = mbX&255  
                        mbX = IO4
                        tcpOutBuf[6] = mbX>>8
                        tcpOutBuf[7] = mbX&255  
                    else
                        mbX = IO5
                        tcpOutBuf[0] = mbX>>8           ; returns 2nd block of analog inputs 
                        tcpOutBuf[1] = mbX&255  
                        mbX = IO6
                        tcpOutBuf[2] = mbX>>8
                        tcpOutBuf[3] = mbX&255  
                        mbX = IO7
                        tcpOutBuf[4] = mbX>>8  
                        tcpOutBuf[5] = mbX&255  
                        mbX = IO8
                        tcpOutBuf[6] = mbX>>8
                        tcpOutBuf[7] = mbX&255  
                    endif
                endif                
            case 0x48                               ;  Get Counter and Capture registers for one channel
                if checkNonce() then
                    Nonce = GenNonce()  
                    cmdIO = tcpInBuf[1]                         ; get counter number
                    select cmdIO
                        case 1  mbX = System_CtrVal1
                                mbFC = System_CtrCapt1
                        case 2  mbX = System_CtrVal2
                                mbFC = System_CtrCapt2
                        case 3  mbX = System_CtrVal3
                                mbFC = System_CtrCapt3
                        case 4  mbX = System_CtrVal4
                                mbFC = System_CtrCapt4
                        case 5  mbX = System_CtrVal5
                                mbFC = System_CtrCapt5
                        case 6  mbX = System_CtrVal6
                                mbFC = System_CtrCapt6
                        case 7  mbX = System_CtrVal7
                                mbFC = System_CtrCapt7
                        case 8  mbX = System_CtrVal8
                                mbFC = System_CtrCapt8
                        else    mbX = 0
                                mbFC = 0
                    endselect
                    tcpOutBuf[0] = mbX>>24
                    tcpOutBuf[1] = mbX>>16  
                    tcpOutBuf[2] = mbX>>8
                    tcpOutBuf[3] = mbX&255              
                    tcpOutBuf[4] = mbFC>>24
                    tcpOutBuf[5] = mbFC>>16     
                    tcpOutBuf[6] = mbFC>>8
                    tcpOutBuf[7] = mbFC&255     
               endif                
        endselect
        if tcpLength>0 tcpip.Write(tcpOutBuf, 16)
    endif
    return
endfunction

function Binary()
	if tcpLength > 0 then 
		NonceIn = Nonce							; not using AES, so just make it equal do DoBinary will work OK.
		DoBinary()
		if(tcpLength) tcpip.Write(tcpOutBuf, tcpLength)
	endif
	return
endfunction		

function AESBinary()
	if tcpLength > 31 then						; needs to be at least 32 bytes 
		aes.decrypt(tcpInBuf, 16)
		x = 12
		NonceIn = tcpInBuf.GetNumBinary(x, 4)					
		for x = 0 to 15 
			tcpOutBuf[x] = 0
		next
		DoBinary()
		aes.encrypt(tcpOutBuf, 16)
		tcpip.Write(tcpOutBuf, 32)
	endif
	return
endfunction	

function loadStatus()
    tcpOutBuf[0] = system.ModuleID      ; 42 for dS2832
    tcpOutBuf[1] = VerMajor             ; Firmware version - major
    tcpOutBuf[2] = VerMinor             ; Firmware version - minor
    tcpOutBuf[3] = AppVerMajor          ; Application Firmware version - major
    tcpOutBuf[4] = AppVerMinor          ; Application Firmware version - minor
    tcpOutBuf[5] = Volts                ; Volts*10, 125 = 12.5v
    tcpOutBuf[6] = BrdTemp>>8           ; internal temperature*10, high byte
    tcpOutBuf[7] = BrdTemp&255          ; internal temperature*10, low byte, (combined to 16 bits, 267 = 26.7 degrees C)
endfunction

function DoBinary()
	tcpLength = 0							; default incase of invalid command
	select tcpInBuf[0]
		case 0x30								; GS, Get Status - returns 6 bytes. 
			tcpOutBuf[0] = system.ModuleID		; 42 for dS2832
			tcpOutBuf[1] = VerMajor				; System Firmware version - major
			tcpOutBuf[2] = VerMinor				; System Firmware version - minor
			tcpOutBuf[3] = AppVerMajor			; Application Firmware version - major
			tcpOutBuf[4] = AppVerMinor			; Application Firmware version - minor
			tcpOutBuf[5] = Volts				; Volts*10, 125 = 12.5v
			tcpOutBuf[6] = BrdTemp>>8			; internal temperature*10, high byte
			tcpOutBuf[7] = BrdTemp&255			; internal temperature*10, low byte, (combined to 16 bits, 267 = 26.7 degrees C)
			Nonce = system.Random
			tcpOutBuf[12] = Nonce >> 24
			tcpOutBuf[13] = Nonce >> 16			; insert Nonce - just in case we are being called by AES mode 
			tcpOutBuf[14] = Nonce >> 8
			tcpOutBuf[15] = Nonce
			tcpLength = 8
				
		case 0x31								; SR, Set Relay - relay num, state, pulse time/state (4 bytes), total 7 byte command
			cmdIO = tcpInBuf[1]											; get relay number
			RlyState = tcpInBuf[2]										; get state (0,1 or 3 for toggle)
			PulseTime = 3		; as a temporary index
			PulseTime = tcpInBuf.GetNumBinary(PulseTime, 4)				; get 4 byte pulse time
			select cmdIO
				case 1 to 32
					if Nonce == NonceIn SetRelay()			; set the relay	
					tcpOutBuf[0] = 0						; ACK
				else
					tcpOutBuf[0] = cmdIO					; NACK, unknown relay number, send relay number as NACK					
			endselect
			Nonce = system.Random
			tcpOutBuf[12] = Nonce >> 24
			tcpOutBuf[13] = Nonce >> 16			; insert Nonce - just in case we are being called by AES mode 
			tcpOutBuf[14] = Nonce >> 8
			tcpOutBuf[15] = Nonce
			tcpLength = 1
				
		case 0x32								; SO, Set Output - output num, state, total 3 byte command
			cmdIO = tcpInBuf[1]											; get output number
			if tcpInBuf[2]==0 then RlyState=off else RlyState=on endif	; get state
			select cmdIO
				case 1 to 8
					if Nonce == NonceIn SetIO()				; set the output	
					tcpOutBuf[0] = 0						; ACK
				else
					tcpOutBuf[0] = cmdIO					; NACK, unknown I/O number, send number as NACK					
			endselect
			Nonce = system.Random
			tcpOutBuf[12] = Nonce >> 24
			tcpOutBuf[13] = Nonce >> 16			; insert Nonce - just in case we are being called by AES mode 
			tcpOutBuf[14] = Nonce >> 8
			tcpOutBuf[15] = Nonce
			tcpLength = 1
				
		case 0x33								; GR, Get Relay - 1st is requested relay, 2nd,3rd,4th are packed relays, 
			tcpOutBuf[0] = 0
			select tcpInBuf[1]
				case 1 if Rly1==on tcpOutBuf[0] = 1
				case 2 if Rly2==on tcpOutBuf[0] = 1
				case 3 if Rly3==on tcpOutBuf[0] = 1
				case 4 if Rly4==on tcpOutBuf[0] = 1
				case 5 if Rly5==on tcpOutBuf[0] = 1
				case 6 if Rly6==on tcpOutBuf[0] = 1
				case 7 if Rly7==on tcpOutBuf[0] = 1
				case 8 if Rly8==on tcpOutBuf[0] = 1
				case 9 if Rly9==on tcpOutBuf[0] = 1
				case 10 if Rly10==on tcpOutBuf[0] = 1
				case 11 if Rly11==on tcpOutBuf[0] = 1
				case 12 if Rly12==on tcpOutBuf[0] = 1
				case 13 if Rly13==on tcpOutBuf[0] = 1
				case 14 if Rly14==on tcpOutBuf[0] = 1
				case 15 if Rly15==on tcpOutBuf[0] = 1
				case 16 if Rly16==on tcpOutBuf[0] = 1
				case 17 if Rly17==on tcpOutBuf[0] = 1
				case 18 if Rly18==on tcpOutBuf[0] = 1
				case 19 if Rly19==on tcpOutBuf[0] = 1
				case 20 if Rly20==on tcpOutBuf[0] = 1
				case 21 if Rly21==on tcpOutBuf[0] = 1
				case 22 if Rly22==on tcpOutBuf[0] = 1
				case 23 if Rly23==on tcpOutBuf[0] = 1
				case 24 if Rly24==on tcpOutBuf[0] = 1
				case 25 if Rly25==on tcpOutBuf[0] = 1
				case 26 if Rly26==on tcpOutBuf[0] = 1
				case 27 if Rly27==on tcpOutBuf[0] = 1
				case 28 if Rly28==on tcpOutBuf[0] = 1
				case 29 if Rly29==on tcpOutBuf[0] = 1
				case 30 if Rly30==on tcpOutBuf[0] = 1
				case 31 if Rly31==on tcpOutBuf[0] = 1
				case 32 if Rly32==on tcpOutBuf[0] = 1
			endselect
			tcpOutBuf[1] = 0
			tcpOutBuf[2] = 0
			tcpOutBuf[3] = 0
			tcpOutBuf[4] = 0
			if Rly1==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x01 endif
			if Rly2==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x02 endif
			if Rly3==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x04 endif
			if Rly4==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x08 endif
			if Rly5==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x10 endif
			if Rly6==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x20 endif
			if Rly7==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x40 endif
			if Rly8==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x80 endif
			if Rly9==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x01 endif
			if Rly10==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x02 endif
			if Rly11==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x04 endif
			if Rly12==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x08 endif
			if Rly13==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x10 endif
			if Rly14==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x20 endif
			if Rly15==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x40 endif
			if Rly16==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x80 endif					
			if Rly17==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x01 endif
			if Rly18==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x02 endif
			if Rly19==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x04 endif
			if Rly20==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x08 endif
			if Rly21==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x10 endif
			if Rly22==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x20 endif
			if Rly23==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x40 endif
			if Rly24==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x80 endif			
			if Rly25==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x01 endif
			if Rly26==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x02 endif
			if Rly27==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x04 endif
			if Rly28==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x08 endif
			if Rly29==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x10 endif
			if Rly30==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x20 endif
			if Rly31==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x40 endif
			if Rly32==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x80 endif
			tcpLength = 5
		
		case 0x34								; GI, Get Input - 1st is requested input, 2nd is packed inputs
			tcpOutBuf[0] = 0
			tcpOutBuf[1] = 0
			select tcpInBuf[1]
				case 1	if IO1==on tcpOutBuf[0] = 1	
				case 2	if IO2==on tcpOutBuf[0] = 1	
				case 3	if IO3==on tcpOutBuf[0] = 1	
				case 4	if IO4==on tcpOutBuf[0] = 1	
				case 5	if IO5==on tcpOutBuf[0] = 1	
				case 6	if IO6==on tcpOutBuf[0] = 1	
				case 7	if IO7==on tcpOutBuf[0] = 1	
				case 8	if IO8==on tcpOutBuf[0] = 1	
			endselect
			if IO1==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x01 endif
			if IO2==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x02 endif
			if IO3==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x04 endif
			if IO4==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x08 endif
			if IO5==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x10 endif
			if IO6==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x20 endif
			if IO7==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x40 endif
			if IO8==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x80 endif
			tcpLength = 2	

		case 0x35							; GA, Get Analog - 1st is high byte, 2nd is low byte of input
			tcpOutBuf[0] = IO1>>8			; returns all 8 analog inputs (some may actually be digital)
			tcpOutBuf[1] = IO1&255 	
			tcpOutBuf[2] = IO2>>8
			tcpOutBuf[3] = IO2&255 	
			tcpOutBuf[4] = IO3>>8
			tcpOutBuf[5] = IO3&255 	
			tcpOutBuf[6] = IO4>>8
			tcpOutBuf[7] = IO4&255 	
			tcpOutBuf[8] = IO5>>8
			tcpOutBuf[9] = IO5&255 	
			tcpOutBuf[10] = IO6>>8
			tcpOutBuf[11] = IO6&255 	
			tcpOutBuf[12] = IO7>>8
			tcpOutBuf[13] = IO7&255 	
			tcpOutBuf[14] = IO8>>8
			tcpOutBuf[15] = IO8&255 	
			tcpLength = 16

		case 0x36										; GC, Get Counter - Counter num, 2 byte command returning 8 bytes
			cmdIO = tcpInBuf[1]							; get counter number
			select cmdIO
				case 1	mbX = System_CtrVal1
						mbFC = System_CtrCapt1
				case 2	mbX = System_CtrVal2
						mbFC = System_CtrCapt2
				case 3	mbX = System_CtrVal3
						mbFC = System_CtrCapt3
				case 4	mbX = System_CtrVal4
						mbFC = System_CtrCapt4
				case 5	mbX = System_CtrVal5
						mbFC = System_CtrCapt5
				case 6	mbX = System_CtrVal6
						mbFC = System_CtrCapt6
				case 7	mbX = System_CtrVal7
						mbFC = System_CtrCapt7
				case 8	mbX = System_CtrVal8
						mbFC = System_CtrCapt8
				else 	mbX = 0
						mbFC = 0
			endselect
			tcpOutBuf[0] = mbX>>24
			tcpOutBuf[1] = mbX>>16 	
			tcpOutBuf[2] = mbX>>8
			tcpOutBuf[3] = mbX&255 				
			tcpOutBuf[4] = mbFC>>24
			tcpOutBuf[5] = mbFC>>16 	
			tcpOutBuf[6] = mbFC>>8
			tcpOutBuf[7] = mbFC&255 	
			tcpLength = 8				

	endselect
endfunction
		
function ModBus()
	if tcpLength < 12 return										; 12 bytes is minimum frame size
	cmdIdx = 0
	mbTI = tcpInBuf.GetNumBinary(cmdIdx,2)							; read MBAP Header
	mbPI = tcpInBuf.GetNumBinary(cmdIdx,2)
	mbLen = tcpInBuf.GetNumBinary(cmdIdx,2)
	mbUI = tcpInBuf.GetNumBinary(cmdIdx,1)
	if mbPI != 0 return												; must be zero for modbus protocol
	if mbLen < 6 return												; must have another 6 bytes minimum
	if mbUI != System_ModbusUID then								; if not for this module, send downstream to additional modules.
		ModBusRTU()
		return
	endif
	mbFC = tcpInBuf.GetNumBinary(cmdIdx,1)							; read command, Function code
	mbSA = tcpInBuf.GetNumBinary(cmdIdx,2)							; source address
	mbNP = tcpInBuf.GetNumBinary(cmdIdx,2)							; number of points
	
	select mbFC
		case 1														; read coils
			ModBus_ReadCoils()
		case 4														; read input registers
			ModBus_ReadInputRegisters()
		case 5														; write single coil
			ModBus_WriteSingleCoil()
		case 15														; write multiple coils
			ModBus_WriteMultipleCoils()
		else
			ModBusErr(1)				
	endselect
endfunction

function ModBus_ReadCoils()												; modbus function 01 (0x01
	if mbSA > 48 then
		ModBusErr(2)
	elseif mbNP == 0 
		ModBusErr(3)
	elseif mbSA+mbNP > 49
		ModBusErr(2)
	else
		cmdIdx = 9														; position of 1st packed data bytes
		tcpInBuf[cmdIdx] = 0
		mbX = 1
		tcpInBuf[8] = 0													; returned byte count
		do
			if mbX == 1 tcpInBuf[8] += 1								; increment returned byte count
			select mbSA
				case  0 if Rly1==active tcpInBuf[cmdIdx] |= mbX			; insert coil/input status
				case  1 if Rly2==active tcpInBuf[cmdIdx] |= mbX			; address 1 is coil 2/Relay 2
				case  2 if Rly3==active tcpInBuf[cmdIdx] |= mbX	
				case  3 if Rly4==active tcpInBuf[cmdIdx] |= mbX
				case  4 if Rly5==active tcpInBuf[cmdIdx] |= mbX
				case  5 if Rly6==active tcpInBuf[cmdIdx] |= mbX
				case  6 if Rly7==active tcpInBuf[cmdIdx] |= mbX
				case  7 if Rly8==active tcpInBuf[cmdIdx] |= mbX
				case  8 if Rly9==active tcpInBuf[cmdIdx] |= mbX
				case  9 if Rly10==active tcpInBuf[cmdIdx] |= mbX
				case  10 if Rly11==active tcpInBuf[cmdIdx] |= mbX
				case  11 if Rly12==active tcpInBuf[cmdIdx] |= mbX
				case  12 if Rly13==active tcpInBuf[cmdIdx] |= mbX
				case  13 if Rly14==active tcpInBuf[cmdIdx] |= mbX
				case  14 if Rly15==active tcpInBuf[cmdIdx] |= mbX
				case  15 if Rly16==active tcpInBuf[cmdIdx] |= mbX
				case  16 if Rly17==active tcpInBuf[cmdIdx] |= mbX
				case  17 if Rly18==active tcpInBuf[cmdIdx] |= mbX
				case  18 if Rly19==active tcpInBuf[cmdIdx] |= mbX
				case  19 if Rly20==active tcpInBuf[cmdIdx] |= mbX
				case  20 if Rly21==active tcpInBuf[cmdIdx] |= mbX
				case  21 if Rly22==active tcpInBuf[cmdIdx] |= mbX
				case  22 if Rly23==active tcpInBuf[cmdIdx] |= mbX
				case  23 if Rly24==active tcpInBuf[cmdIdx] |= mbX
				case  24 if Rly25==active tcpInBuf[cmdIdx] |= mbX
				case  25 if Rly26==active tcpInBuf[cmdIdx] |= mbX
				case  26 if Rly27==active tcpInBuf[cmdIdx] |= mbX
				case  27 if Rly28==active tcpInBuf[cmdIdx] |= mbX
				case  28 if Rly29==active tcpInBuf[cmdIdx] |= mbX
				case  29 if Rly30==active tcpInBuf[cmdIdx] |= mbX
				case  30 if Rly31==active tcpInBuf[cmdIdx] |= mbX
				case  31 if Rly32==active tcpInBuf[cmdIdx] |= mbX

				case 40 if IO1==active  tcpInBuf[cmdIdx] |= mbX			; IO1-8 are remapped to coils 41-48
				case 41 if IO2==active  tcpInBuf[cmdIdx] |= mbX			; address 41 is Coil 42/IO2
				case 42 if IO3==active  tcpInBuf[cmdIdx] |= mbX
				case 43 if IO4==active  tcpInBuf[cmdIdx] |= mbX
				case 44 if IO5==active  tcpInBuf[cmdIdx] |= mbX
				case 45 if IO6==active  tcpInBuf[cmdIdx] |= mbX
				case 46 if IO7==active  tcpInBuf[cmdIdx] |= mbX
				case 47 if IO8==active  tcpInBuf[cmdIdx] |= mbX
			endselect
			mbX <<= 1
			if mbX == 0x100 then
				mbX = 1
				cmdIdx += 1
				tcpInBuf[cmdIdx] = 0
			endif
			mbNP -= 1
			mbSA += 1
		loop while mbNP > 0
		tcpInBuf[4] = 0
		tcpInBuf[5] = tcpInBuf[8]+3										; place length in MBAP
		tcpip.Write(tcpInBuf, tcpInBuf[8]+9)
	endif
endfunction

function ModBus_ReadInputRegisters()									; modbus function 04 (0x04)
	if mbSA > 40 then
		ModBusErr(2)
	elseif mbNP == 0 
		ModBusErr(3)
	elseif mbSA+mbNP > 41
		ModBusErr(2)
	else
		cmdIdx = 9														; position of 1st packed data bytes
		tcpInBuf[8] = 0													; returned byte count
		do
			tcpInBuf[8] += 2											; increment returned byte count
			select mbSA
				case  0 mbX = IO1										; insert analogue input reading
						tcpInBuf[cmdIdx] = mbX >> 8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = mbX & 0xff
						cmdIdx += 1
				case  1 mbX = IO2
						tcpInBuf[cmdIdx] = mbX >> 8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = mbX & 0xff
						cmdIdx += 1
				case  2 mbX = IO3
						tcpInBuf[cmdIdx] = mbX >> 8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = mbX & 0xff
						cmdIdx += 1
				case  3 mbX = IO4
						tcpInBuf[cmdIdx] = mbX >> 8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = mbX & 0xff
						cmdIdx += 1
				case  4 mbX = IO5
						tcpInBuf[cmdIdx] = mbX >> 8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = mbX & 0xff
						cmdIdx += 1
				case  5 mbX = IO6
						tcpInBuf[cmdIdx] = mbX >> 8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = mbX & 0xff
						cmdIdx += 1
				case  6 mbX = IO7
						tcpInBuf[cmdIdx] = mbX >> 8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = mbX & 0xff
						cmdIdx += 1
				case  7 mbX = IO8
						tcpInBuf[cmdIdx] = mbX >> 8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = mbX & 0xff
						cmdIdx += 1
				case  8	tcpInBuf[cmdIdx] = System_CtrVal1>>24
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrVal1>>16
						cmdIdx += 1
				case 9	tcpInBuf[cmdIdx] = System_CtrVal1>>8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrVal1
						cmdIdx += 1
				case 10 tcpInBuf[cmdIdx] = System_CtrVal2>>24
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrVal2>>16
						cmdIdx += 1
				case 11	tcpInBuf[cmdIdx] = System_CtrVal2>>8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrVal2
						cmdIdx += 1
				case 12 tcpInBuf[cmdIdx] = System_CtrVal3>>24
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrVal3>>16
						cmdIdx += 1
				case 13	tcpInBuf[cmdIdx] = System_CtrVal3>>8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrVal3
						cmdIdx += 1
				case 14 tcpInBuf[cmdIdx] = System_CtrVal4>>24
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrVal4>>16
						cmdIdx += 1
				case 15	tcpInBuf[cmdIdx] = System_CtrVal4>>8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrVal4
						cmdIdx += 1
				case 16 tcpInBuf[cmdIdx] = System_CtrVal5>>24
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrVal5>>16
						cmdIdx += 1
				case 17	tcpInBuf[cmdIdx] = System_CtrVal5>>8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrVal5
						cmdIdx += 1
				case 18 tcpInBuf[cmdIdx] = System_CtrVal6>>24
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrVal6>>16
						cmdIdx += 1
				case 19	tcpInBuf[cmdIdx] = System_CtrVal6>>8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrVal6
						cmdIdx += 1
				case 20 tcpInBuf[cmdIdx] = System_CtrVal7>>24
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrVal7>>16
						cmdIdx += 1
				case 21	tcpInBuf[cmdIdx] = System_CtrVal7>>8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrVal7
						cmdIdx += 1
				case 22 tcpInBuf[cmdIdx] = System_CtrVal8>>24
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrVal8>>16
						cmdIdx += 1
				case 23	tcpInBuf[cmdIdx] = System_CtrVal8>>8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrVal8
						cmdIdx += 1
						
				case 24	tcpInBuf[cmdIdx] = System_CtrCapt1>>24
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrCapt1>>16
						cmdIdx += 1
				case 25	tcpInBuf[cmdIdx] = System_CtrCapt1>>8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrCapt1
						cmdIdx += 1
				case 26 tcpInBuf[cmdIdx] = System_CtrCapt2>>24
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrCapt2>>16
						cmdIdx += 1
				case 27	tcpInBuf[cmdIdx] = System_CtrCapt2>>8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrCapt2
						cmdIdx += 1
				case 28 tcpInBuf[cmdIdx] = System_CtrCapt3>>24
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrCapt3>>16
						cmdIdx += 1
				case 29	tcpInBuf[cmdIdx] = System_CtrCapt3>>8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrCapt3
						cmdIdx += 1
				case 30 tcpInBuf[cmdIdx] = System_CtrCapt4>>24
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrCapt4>>16
						cmdIdx += 1
				case 31	tcpInBuf[cmdIdx] = System_CtrCapt4>>8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrCapt4
						cmdIdx += 1
				case 32 tcpInBuf[cmdIdx] = System_CtrCapt5>>24
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrCapt5>>16
						cmdIdx += 1
				case 33	tcpInBuf[cmdIdx] = System_CtrCapt5>>8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrCapt5
						cmdIdx += 1
				case 34 tcpInBuf[cmdIdx] = System_CtrCapt6>>24
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrCapt6>>16
						cmdIdx += 1
				case 35	tcpInBuf[cmdIdx] = System_CtrCapt6>>8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrCapt6
						cmdIdx += 1
				case 36 tcpInBuf[cmdIdx] = System_CtrCapt7>>24
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrCapt7>>16
						cmdIdx += 1
				case 37 tcpInBuf[cmdIdx] = System_CtrCapt7>>8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrCapt7
						cmdIdx += 1
				case 38 tcpInBuf[cmdIdx] = System_CtrCapt8>>24
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrCapt8>>16
						cmdIdx += 1
				case 39	tcpInBuf[cmdIdx] = System_CtrCapt8>>8
						cmdIdx += 1
						tcpInBuf[cmdIdx] = System_CtrCapt8
						cmdIdx += 1
			endselect
			mbNP -= 1
			mbSA += 1
		loop while mbNP > 0
		tcpInBuf[4] = 0
		tcpInBuf[5] = tcpInBuf[8]+3										; place length in MBAP
		tcpip.Write(tcpInBuf, tcpInBuf[8]+9)
	endif
endfunction

function ModBus_WriteSingleCoil()										; modbus function 05 (0x05)
	if mbSA > 48 then
		ModBusErr(2)
	elseif mbNP != 0xff00 and mbNP != 0 then
		ModBusErr(3)
	else
		select mbSA
			case  0 if mbNP==0xff00 then Rly1=on else Rly1=off endif	; write to selected coil (relay or IO)
			case  1 if mbNP==0xff00 then Rly2=on else Rly2=off endif
			case  2 if mbNP==0xff00 then Rly3=on else Rly3=off endif
			case  3 if mbNP==0xff00 then Rly4=on else Rly4=off endif
			case  4 if mbNP==0xff00 then Rly5=on else Rly5=off endif
			case  5 if mbNP==0xff00 then Rly6=on else Rly6=off endif
			case  6 if mbNP==0xff00 then Rly7=on else Rly7=off endif
			case  7 if mbNP==0xff00 then Rly8=on else Rly8=off endif
			case  8 if mbNP==0xff00 then Rly9=on else Rly9=off endif
			case  9 if mbNP==0xff00 then Rly10=on else Rly10=off endif
			case  10 if mbNP==0xff00 then Rly11=on else Rly11=off endif
			case  11 if mbNP==0xff00 then Rly12=on else Rly12=off endif
			case  12 if mbNP==0xff00 then Rly13=on else Rly13=off endif
			case  13 if mbNP==0xff00 then Rly14=on else Rly14=off endif
			case  14 if mbNP==0xff00 then Rly15=on else Rly15=off endif
			case  15 if mbNP==0xff00 then Rly16=on else Rly16=off endif
			case  16 if mbNP==0xff00 then Rly17=on else Rly17=off endif
			case  17 if mbNP==0xff00 then Rly18=on else Rly18=off endif
			case  18 if mbNP==0xff00 then Rly19=on else Rly19=off endif
			case  19 if mbNP==0xff00 then Rly20=on else Rly20=off endif
			case  20 if mbNP==0xff00 then Rly21=on else Rly21=off endif
			case  21 if mbNP==0xff00 then Rly22=on else Rly22=off endif
			case  22 if mbNP==0xff00 then Rly23=on else Rly23=off endif
			case  23 if mbNP==0xff00 then Rly24=on else Rly24=off endif
			case  24 if mbNP==0xff00 then Rly25=on else Rly25=off endif
			case  25 if mbNP==0xff00 then Rly26=on else Rly26=off endif
			case  26 if mbNP==0xff00 then Rly27=on else Rly27=off endif
			case  27 if mbNP==0xff00 then Rly28=on else Rly28=off endif
			case  28 if mbNP==0xff00 then Rly29=on else Rly29=off endif
			case  29 if mbNP==0xff00 then Rly30=on else Rly30=off endif
			case  30 if mbNP==0xff00 then Rly31=on else Rly31=off endif
			case  31 if mbNP==0xff00 then Rly32=on else Rly32=off endif

			case 40 if mbNP==0xff00 then IO1=on else IO1=off endif		; IO1-8 are remapped to coils 41-48
			case 41 if mbNP==0xff00 then IO2=on else IO2=off endif
			case 42 if mbNP==0xff00 then IO3=on else IO3=off endif
			case 43 if mbNP==0xff00 then IO4=on else IO4=off endif
			case 44 if mbNP==0xff00 then IO5=on else IO5=off endif
			case 45 if mbNP==0xff00 then IO6=on else IO6=off endif
			case 46 if mbNP==0xff00 then IO7=on else IO7=off endif
			case 47 if mbNP==0xff00 then IO8=on else IO8=off endif
		endselect
		tcpInBuf[4] = 0
		tcpInBuf[5] = 4													; place length in MBAP
		tcpip.Write(tcpInBuf, 10)
	endif
endfunction
		
function ModBus_WriteMultipleCoils()
	if mbSA > 48 then
		ModBusErr(2)
	elseif mbNP == 0 
		ModBusErr(3)
	elseif mbSA+mbNP > 49
		ModBusErr(3)
	else
		cmdIdx = 13														; position of 1st packed data bytes
		mbX = 1

		do
			select mbSA
				case  0 if tcpInBuf[cmdIdx]&mbX then Rly1=on else Rly1=off endif	; write to selected coil (relay or IO)
				case  1 if tcpInBuf[cmdIdx]&mbX then Rly2=on else Rly2=off endif
				case  2 if tcpInBuf[cmdIdx]&mbX then Rly3=on else Rly3=off endif
				case  3 if tcpInBuf[cmdIdx]&mbX then Rly4=on else Rly4=off endif
				case  4 if tcpInBuf[cmdIdx]&mbX then Rly5=on else Rly5=off endif
				case  5 if tcpInBuf[cmdIdx]&mbX then Rly6=on else Rly6=off endif
				case  6 if tcpInBuf[cmdIdx]&mbX then Rly7=on else Rly7=off endif
				case  7 if tcpInBuf[cmdIdx]&mbX then Rly8=on else Rly8=off endif
				case  8 if tcpInBuf[cmdIdx]&mbX then Rly9=on else Rly9=off endif
				case  9 if tcpInBuf[cmdIdx]&mbX then Rly10=on else Rly10=off endif
				case  10 if tcpInBuf[cmdIdx]&mbX then Rly11=on else Rly11=off endif
				case  11 if tcpInBuf[cmdIdx]&mbX then Rly12=on else Rly12=off endif
				case  12 if tcpInBuf[cmdIdx]&mbX then Rly13=on else Rly13=off endif
				case  13 if tcpInBuf[cmdIdx]&mbX then Rly14=on else Rly14=off endif
				case  14 if tcpInBuf[cmdIdx]&mbX then Rly15=on else Rly15=off endif
				case  15 if tcpInBuf[cmdIdx]&mbX then Rly16=on else Rly16=off endif
				case  16 if tcpInBuf[cmdIdx]&mbX then Rly17=on else Rly17=off endif
				case  17 if tcpInBuf[cmdIdx]&mbX then Rly18=on else Rly18=off endif
				case  18 if tcpInBuf[cmdIdx]&mbX then Rly19=on else Rly19=off endif
				case  19 if tcpInBuf[cmdIdx]&mbX then Rly20=on else Rly20=off endif
				case  20 if tcpInBuf[cmdIdx]&mbX then Rly21=on else Rly21=off endif
				case  21 if tcpInBuf[cmdIdx]&mbX then Rly22=on else Rly22=off endif
				case  22 if tcpInBuf[cmdIdx]&mbX then Rly23=on else Rly23=off endif
				case  23 if tcpInBuf[cmdIdx]&mbX then Rly24=on else Rly24=off endif
				case  24 if tcpInBuf[cmdIdx]&mbX then Rly25=on else Rly25=off endif
				case  25 if tcpInBuf[cmdIdx]&mbX then Rly26=on else Rly26=off endif
				case  26 if tcpInBuf[cmdIdx]&mbX then Rly27=on else Rly27=off endif
				case  27 if tcpInBuf[cmdIdx]&mbX then Rly28=on else Rly28=off endif
				case  28 if tcpInBuf[cmdIdx]&mbX then Rly29=on else Rly29=off endif
				case  29 if tcpInBuf[cmdIdx]&mbX then Rly30=on else Rly30=off endif
				case  30 if tcpInBuf[cmdIdx]&mbX then Rly31=on else Rly31=off endif
				case  31 if tcpInBuf[cmdIdx]&mbX then Rly32=on else Rly32=off endif
	
				case 40 if tcpInBuf[cmdIdx]&mbX then IO1=on else IO1=off endif		; IO1-8 are remapped to coils 41-48
				case 41 if tcpInBuf[cmdIdx]&mbX then IO2=on else IO2=off endif		; (addresses 40-47)
				case 42 if tcpInBuf[cmdIdx]&mbX then IO3=on else IO3=off endif
				case 43 if tcpInBuf[cmdIdx]&mbX then IO4=on else IO4=off endif
				case 44 if tcpInBuf[cmdIdx]&mbX then IO5=on else IO5=off endif
				case 45 if tcpInBuf[cmdIdx]&mbX then IO6=on else IO6=off endif
				case 46 if tcpInBuf[cmdIdx]&mbX then IO7=on else IO7=off endif
				case 47 if tcpInBuf[cmdIdx]&mbX then IO8=on else IO8=off endif
			endselect
			mbX <<= 1
			if mbX == 0x100 then
				mbX = 1
				cmdIdx += 1
			endif
			mbNP -= 1
			mbSA += 1
		loop while mbNP > 0
		
		tcpInBuf[4] = 0
		tcpInBuf[5] = 6													; place length in MBAP
		tcpip.Write(tcpInBuf, 12)
	endif
endfunction
	
function ModBusErr(int8 mbErr) 
	tcpInBuf[4] = 0
	tcpInBuf[5] = 3														; count of following bytes
	tcpInBuf[7] |= 0x80													; merge error flag with function code
	tcpInBuf[8] = mbErr													; error code
	tcpip.Write(tcpInBuf, 9)											; send the modified input buffer
endfunction

function ModBusRTU()
	for mbX=0 to mbLen rtu[mbX] = tcpInBuf[mbX+6] next					; extract the address and PDU from the ADU
	crc = rtu.CRC(mbLen)												; calculate the CRC
	rtu[mbLen] = crc&255												; and append it to the frame
	rtu[mbLen+1] = crc>>8
	ModbusRTU.Write(rtu, 0, mbLen+2)									; send RTU frame to downstream module
	threadsleep 3*mbLen													; allow time to transmit the frame and start getting the response
	do
		crc = ModbusRTU.BytesToRead										; crc is just used to hold data byte count
		threadsleep 2													; 2mS with no further bytes coming in is assumed to be end of data
	loop while ModbusRTU.BytesToRead>crc
	if crc == 0 then
		ModBusErr(0x0B)													; gateway target faild to respond
		return
	endif
	ModbusRTU.Read(tcpInBuf, 6, crc)
    crc -= 2                                                            ; strip CRC from the RTU message, as TCP has its own CRC
    tcpInBuf[4] = crc>>8                                                ; count of following bytes
	tcpInBuf[5] = crc&255
	tcpip.Write(tcpInBuf, crc+6)										; send the modified input buffer
endfunction	

thread P2P(const)
	do																; Peer to Peer, remote relay control
		if System_P2P_Port1 > 0 then									; Entry is valid
			P2Pbool = System_P2P_Input1.BooleanEval() 	
			if P2Pbool != P2Pbool1 then		
				P2Pcmd[0] = 0x31
				P2Pcmd[1] = System_P2P_Relay1
				P2Pcmd[2] = P2Pbool
				P2Pcmd[3] = 0
				P2Pcmd[4] = 0
				P2Pcmd[5] = 0
				P2Pcmd[6] = 0
				select 	System_P2P_Action1
					case 1												; follow me
						SendP2P1()
					case 2												; set relay
						if P2Pbool then 
							P2Pcmd[2] = 1
							SendP2P1()
						else
							P2Pbool1 = P2Pbool 
						endif						
					case 3												; reset relay
						if P2Pbool then 
							P2Pcmd[2] = 0
							SendP2P1()
						else
							P2Pbool1 = P2Pbool 
						endif									
					case 4												; toggle relay
						if P2Pbool then 
							P2Pcmd[2] = 3
							SendP2P1()
						else 
							P2Pbool1 = P2Pbool 
						endif
					else
						if P2Pbool then 
							if System_P2P_Action1>MinRelayPulse then					; 100+ pulse relay
								P2Pcmd[3] = System_P2P_Action1>>24
								P2Pcmd[4] = System_P2P_Action1>>16
								P2Pcmd[5] = System_P2P_Action1>>8
								P2Pcmd[6] = System_P2P_Action1
								SendP2P1()							
								P2Pbool1 = P2Pbool 
							endif
						else 
							P2Pbool1 = P2Pbool 
						endif							
				endselect
			endif
		endif
		
		if System_P2P_Port2 > 0 then									; Entry is valid
			P2Pbool = System_P2P_Input2.BooleanEval() 	
			if P2Pbool != P2Pbool2 then		
				P2Pcmd[0] = 0x31
				P2Pcmd[1] = System_P2P_Relay2
				P2Pcmd[2] = P2Pbool
				P2Pcmd[3] = 0
				P2Pcmd[4] = 0
				P2Pcmd[5] = 0
				P2Pcmd[6] = 0
				select 	System_P2P_Action2
					case 1												; follow me
							SendP2P2()
					case 2												; set relay
						if P2Pbool then 
							P2Pcmd[2] = 1
							SendP2P2()
						else
							P2Pbool2 = P2Pbool 
						endif						
					case 3												; reset relay
						if P2Pbool then 
							P2Pcmd[2] = 0
							SendP2P2()
						else
							P2Pbool2 = P2Pbool 
						endif									
					case 4												; toggle relay
						if P2Pbool then 
							P2Pcmd[2] = 3
							SendP2P2()
						else 
							P2Pbool2 = P2Pbool 
						endif
					else
						if P2Pbool then 
							if System_P2P_Action2>MinRelayPulse then					; 100+ pulse relay
								P2Pcmd[3] = System_P2P_Action2>>24
								P2Pcmd[4] = System_P2P_Action2>>16
								P2Pcmd[5] = System_P2P_Action2>>8
								P2Pcmd[6] = System_P2P_Action2
								SendP2P2()							
								P2Pbool2 = P2Pbool 
							endif
						else 
							P2Pbool2 = P2Pbool 
						endif							
				endselect
			endif
		endif
		
		if System_P2P_Port3 > 0 then									; Entry is valid
			P2Pbool = System_P2P_Input3.BooleanEval() 	
			if P2Pbool != P2Pbool3 then		
				P2Pcmd[0] = 0x31
				P2Pcmd[1] = System_P2P_Relay3
				P2Pcmd[2] = P2Pbool
				P2Pcmd[3] = 0
				P2Pcmd[4] = 0
				P2Pcmd[5] = 0
				P2Pcmd[6] = 0
				select 	System_P2P_Action3
					case 1												; follow me
							SendP2P3()
					case 2												; set relay
						if P2Pbool then 
							P2Pcmd[2] = 1
							SendP2P3()
						else
							P2Pbool3 = P2Pbool 
						endif						
					case 3												; reset relay
						if P2Pbool then 
							P2Pcmd[2] = 0
							SendP2P3()
						else
							P2Pbool3 = P2Pbool 
						endif									
					case 4												; toggle relay
						if P2Pbool then 
							P2Pcmd[2] = 3
							SendP2P3()
						else 
							P2Pbool3 = P2Pbool 
						endif
					else
						if P2Pbool then 
							if System_P2P_Action3>MinRelayPulse then					; 100+ pulse relay
								P2Pcmd[3] = System_P2P_Action3>>24
								P2Pcmd[4] = System_P2P_Action3>>16
								P2Pcmd[5] = System_P2P_Action3>>8
								P2Pcmd[6] = System_P2P_Action3
								SendP2P3()							
								P2Pbool3 = P2Pbool 
							endif
						else 
							P2Pbool3 = P2Pbool 
						endif							
				endselect
			endif
		endif
				
		if System_P2P_Port4 > 0 then									; Entry is valid
			P2Pbool = System_P2P_Input4.BooleanEval() 	
			if P2Pbool != P2Pbool4 then		
				P2Pcmd[0] = 0x31
				P2Pcmd[1] = System_P2P_Relay4
				P2Pcmd[2] = P2Pbool
				P2Pcmd[3] = 0
				P2Pcmd[4] = 0
				P2Pcmd[5] = 0
				P2Pcmd[6] = 0
				select 	System_P2P_Action4
					case 1												; follow me
							SendP2P4()
					case 2												; set relay
						if P2Pbool then 
							P2Pcmd[2] = 1
							SendP2P4()
						else
							P2Pbool4 = P2Pbool 
						endif						
					case 3												; reset relay
						if P2Pbool then 
							P2Pcmd[2] = 0
							SendP2P4()
						else
							P2Pbool4 = P2Pbool 
						endif									
					case 4												; toggle relay
						if P2Pbool then 
							P2Pcmd[2] = 3
							SendP2P4()
						else 
							P2Pbool4 = P2Pbool 
						endif
					else
						if P2Pbool then 
							if System_P2P_Action4>MinRelayPulse then					; 100+ pulse relay
								P2Pcmd[3] = System_P2P_Action4>>24
								P2Pcmd[4] = System_P2P_Action4>>16
								P2Pcmd[5] = System_P2P_Action4>>8
								P2Pcmd[6] = System_P2P_Action4
								SendP2P4()							
								P2Pbool4 = P2Pbool 
							endif
						else 
							P2Pbool4 = P2Pbool 
						endif							
				endselect
			endif
		endif
				
		if System_P2P_Port5 > 0 then									; Entry is valid
			P2Pbool = System_P2P_Input5.BooleanEval() 	
			if P2Pbool != P2Pbool5 then		
				P2Pcmd[0] = 0x31
				P2Pcmd[1] = System_P2P_Relay5
				P2Pcmd[2] = P2Pbool
				P2Pcmd[3] = 0
				P2Pcmd[4] = 0
				P2Pcmd[5] = 0
				P2Pcmd[6] = 0
				select 	System_P2P_Action5
					case 1												; follow me
							SendP2P5()
					case 2												; set relay
						if P2Pbool then 
							P2Pcmd[2] = 1
							SendP2P5()
						else
							P2Pbool5 = P2Pbool 
						endif						
					case 3												; reset relay
						if P2Pbool then 
							P2Pcmd[2] = 0
							SendP2P5()
						else
							P2Pbool5 = P2Pbool 
						endif									
					case 4												; toggle relay
						if P2Pbool then 
							P2Pcmd[2] = 3
							SendP2P5()
						else 
							P2Pbool5 = P2Pbool 
						endif
					else
						if P2Pbool then 
							if System_P2P_Action5>MinRelayPulse then					; 100+ pulse relay
								P2Pcmd[3] = System_P2P_Action5>>24
								P2Pcmd[4] = System_P2P_Action5>>16
								P2Pcmd[5] = System_P2P_Action5>>8
								P2Pcmd[6] = System_P2P_Action5
								SendP2P5()							
								P2Pbool5 = P2Pbool 
							endif
						else 
							P2Pbool5 = P2Pbool 
						endif							
				endselect
			endif
		endif
				
		if System_P2P_Port6 > 0 then									; Entry is valid
			P2Pbool = System_P2P_Input6.BooleanEval() 	
			if P2Pbool != P2Pbool6 then		
				P2Pcmd[0] = 0x31
				P2Pcmd[1] = System_P2P_Relay6
				P2Pcmd[2] = P2Pbool
				P2Pcmd[3] = 0
				P2Pcmd[4] = 0
				P2Pcmd[5] = 0
				P2Pcmd[6] = 0
				select 	System_P2P_Action6
					case 1												; follow me
							SendP2P6()
					case 2												; set relay
						if P2Pbool then 
							P2Pcmd[2] = 1
							SendP2P6()
						else
							P2Pbool6 = P2Pbool 
						endif						
					case 3												; reset relay
						if P2Pbool then 
							P2Pcmd[2] = 0
							SendP2P6()
						else
							P2Pbool6 = P2Pbool 
						endif									
					case 4												; toggle relay
						if P2Pbool then 
							P2Pcmd[2] = 3
							SendP2P6()
						else 
							P2Pbool6 = P2Pbool 
						endif
					else
						if P2Pbool then 
							if System_P2P_Action6>MinRelayPulse then					; 100+ pulse relay
								P2Pcmd[3] = System_P2P_Action6>>24
								P2Pcmd[4] = System_P2P_Action6>>16
								P2Pcmd[5] = System_P2P_Action6>>8
								P2Pcmd[6] = System_P2P_Action6
								SendP2P6()							
								P2Pbool6 = P2Pbool 
							endif
						else 
							P2Pbool6 = P2Pbool 
						endif							
				endselect
			endif
		endif
				
		if System_P2P_Port7 > 0 then									; Entry is valid
			P2Pbool = System_P2P_Input7.BooleanEval() 	
			if P2Pbool != P2Pbool7 then		
				P2Pcmd[0] = 0x31
				P2Pcmd[1] = System_P2P_Relay7
				P2Pcmd[2] = P2Pbool
				P2Pcmd[3] = 0
				P2Pcmd[4] = 0
				P2Pcmd[5] = 0
				P2Pcmd[6] = 0
				select 	System_P2P_Action7
					case 1												; follow me
							SendP2P7()
					case 2												; set relay
						if P2Pbool then 
							P2Pcmd[2] = 1
							SendP2P7()
						else
							P2Pbool7 = P2Pbool 
						endif						
					case 3												; reset relay
						if P2Pbool then 
							P2Pcmd[2] = 0
							SendP2P7()
						else
							P2Pbool7 = P2Pbool 
						endif									
					case 4												; toggle relay
						if P2Pbool then 
							P2Pcmd[2] = 3
							SendP2P7()
						else 
							P2Pbool7 = P2Pbool 
						endif
					else
						if P2Pbool then 
							if System_P2P_Action7>MinRelayPulse then					; 100+ pulse relay
								P2Pcmd[3] = System_P2P_Action7>>24
								P2Pcmd[4] = System_P2P_Action7>>16
								P2Pcmd[5] = System_P2P_Action7>>8
								P2Pcmd[6] = System_P2P_Action7
								SendP2P7()							
								P2Pbool7 = P2Pbool 
							endif
						else 
							P2Pbool7 = P2Pbool 
						endif							
				endselect
			endif
		endif
				
		if System_P2P_Port8 > 0 then									; Entry is valid
			P2Pbool = System_P2P_Input8.BooleanEval() 	
			if P2Pbool != P2Pbool8 then		
				P2Pcmd[0] = 0x31
				P2Pcmd[1] = System_P2P_Relay8
				P2Pcmd[2] = P2Pbool
				P2Pcmd[3] = 0
				P2Pcmd[4] = 0
				P2Pcmd[5] = 0
				P2Pcmd[6] = 0
				select 	System_P2P_Action8
					case 1												; follow me
							SendP2P8()
					case 2												; set relay
						if P2Pbool then 
							P2Pcmd[2] = 1
							SendP2P8()
						else
							P2Pbool8 = P2Pbool 
						endif						
					case 3												; reset relay
						if P2Pbool then 
							P2Pcmd[2] = 0
							SendP2P8()
						else
							P2Pbool8 = P2Pbool 
						endif									
					case 4												; toggle relay
						if P2Pbool then 
							P2Pcmd[2] = 3
							SendP2P8()
						else 
							P2Pbool8 = P2Pbool 
						endif
					else
						if P2Pbool then 
							if System_P2P_Action8>MinRelayPulse then					; 100+ pulse relay
								P2Pcmd[3] = System_P2P_Action8>>24
								P2Pcmd[4] = System_P2P_Action8>>16
								P2Pcmd[5] = System_P2P_Action8>>8
								P2Pcmd[6] = System_P2P_Action8
								SendP2P8()							
								P2Pbool8 = P2Pbool 
							endif
						else 
							P2Pbool8 = P2Pbool 
						endif							
				endselect
			endif
		endif				
	loop
endthread

function GetNonce()
	nonce[0] = 0x30
	aes.encrypt(nonce, 16)
	p2p1.Write(nonce, 32, nonce, P2Plength)
	aes.decrypt(nonce, 16)
	P2Pcmd[12] = nonce[12]
	P2Pcmd[13] = nonce[13]
	P2Pcmd[14] = nonce[14]
	P2Pcmd[15] = nonce[15]
	threadsleep 300
	return
endfunction

function SendP2P1()
	if System_P2P_AES & 0x01 then
		GetNonce()
		aes.encrypt(P2Pcmd, 16)
		p2p1.Write(P2Pcmd, 32, P2Pcmd, P2Plength)
		aes.decrypt(P2Pcmd, 16)
	else
		p2p1.Write(P2Pcmd, 32, P2Pcmd, P2Plength)
	endif	
	if P2Plength>0 then
		if P2Pcmd[0]==0 then 
			P2Pbool1 = P2Pbool 
		endif
	endif
	threadsleep 300
endfunction	

function SendP2P2()
	if System_P2P_AES & 0x02 then
		GetNonce()
		aes.encrypt(P2Pcmd, 16)
		p2p2.Write(P2Pcmd, 32, P2Pcmd, P2Plength)
		aes.decrypt(P2Pcmd, 16)
	else
		p2p2.Write(P2Pcmd, 32, P2Pcmd, P2Plength)
	endif
	if P2Plength>0 then
		if P2Pcmd[0]==0 then 
			P2Pbool2 = P2Pbool 
		endif
	endif
	threadsleep 300
endfunction		

function SendP2P3()
	if System_P2P_AES & 0x04 then
		GetNonce()
		aes.encrypt(P2Pcmd, 16)
		p2p3.Write(P2Pcmd, 32, P2Pcmd, P2Plength)
		aes.decrypt(P2Pcmd, 16)
	else
		p2p3.Write(P2Pcmd, 32, P2Pcmd, P2Plength)
	endif
	if P2Plength>0 then
		if P2Pcmd[0]==0 then 
			P2Pbool3 = P2Pbool 
		endif
	endif
	threadsleep 300
endfunction		

function SendP2P4()
	if System_P2P_AES & 0x08 then
		GetNonce()
		aes.encrypt(P2Pcmd, 16)
		p2p4.Write(P2Pcmd, 32, P2Pcmd, P2Plength)
		aes.decrypt(P2Pcmd, 16)
	else
		p2p4.Write(P2Pcmd, 32, P2Pcmd, P2Plength)
	endif
	if P2Plength>0 then
		if P2Pcmd[0]==0 then 
			P2Pbool4 = P2Pbool 
		endif
	endif
	threadsleep 300
endfunction		

function SendP2P5()
	if System_P2P_AES & 0x10 then
		GetNonce()
		aes.encrypt(P2Pcmd, 16)
		p2p5.Write(P2Pcmd, 32, P2Pcmd, P2Plength)
		aes.decrypt(P2Pcmd, 16)
	else
		p2p5.Write(P2Pcmd, 32, P2Pcmd, P2Plength)
	endif
	if P2Plength>0 then
		if P2Pcmd[0]==0 then 
			P2Pbool5 = P2Pbool 
		endif
	endif
	threadsleep 300
endfunction		

function SendP2P6()
	if System_P2P_AES & 0x20 then
		GetNonce()
		aes.encrypt(P2Pcmd, 16)
		p2p6.Write(P2Pcmd, 32, P2Pcmd, P2Plength)
		aes.decrypt(P2Pcmd, 16)
	else
		p2p6.Write(P2Pcmd, 32, P2Pcmd, P2Plength)
	endif
	if P2Plength>0 then
		if P2Pcmd[0]==0 then 
			P2Pbool6 = P2Pbool 
		endif
	endif
	threadsleep 300
endfunction		

function SendP2P7()
	if System_P2P_AES & 0x40 then
		GetNonce()
		aes.encrypt(P2Pcmd, 16)
		p2p7.Write(P2Pcmd, 32, P2Pcmd, P2Plength)
		aes.decrypt(P2Pcmd, 16)
	else
		p2p7.Write(P2Pcmd, 32, P2Pcmd, P2Plength)
	endif
	if P2Plength>0 then
		if P2Pcmd[0]==0 then 
			P2Pbool7 = P2Pbool 
		endif
	endif
	threadsleep 300
endfunction		

function SendP2P8()
	if System_P2P_AES & 0x80 then
		GetNonce()
		aes.encrypt(P2Pcmd, 16)
		p2p8.Write(P2Pcmd, 32, P2Pcmd, P2Plength)
		aes.decrypt(P2Pcmd, 16)
	else
		p2p8.Write(P2Pcmd, 32, P2Pcmd, P2Plength)
	endif
	if P2Plength>0 then
		if P2Pcmd[0]==0 then 
			P2Pbool8 = P2Pbool 
		endif
	endif
	threadsleep 300
endfunction			 


	
